<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/dp%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/dp%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的dp问题"><a href="#常见的dp问题" class="headerlink" title="常见的dp问题"></a>常见的dp问题</h2><h3 id="1-钢条切割问题"><a href="#1-钢条切割问题" class="headerlink" title="1. 钢条切割问题"></a>1. <strong>钢条切割问题</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m 10005</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">10000005</span>];<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[m];<span class="hljs-comment">//长度为m的钢管的最大价值 </span><br><span class="hljs-type">int</span> a[m];<span class="hljs-comment">//存分割方式</span><br><span class="hljs-type">int</span> s[m];<br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<span class="hljs-comment">//钢管总长度</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p[i]);<span class="hljs-comment">//长度为i的钢管对应的价格</span><br>        dp[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i-j]+p[j]&gt;dp[i])&#123;<br>                dp[i]=dp[i-j]+p[j];<br>                a[i]=j;<br>            &#125;<br>        &#125;<br>    &#125; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[n]);<br><br>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>     s[num++]=a[n];<br>     n=n-a[n];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,num);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,s[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. <strong>背包问题</strong></h3><p>有一个容量为V的背包，还有n个物体。现在忽略物体实际几何形状，我们认为只要背包的剩余容量大于等于物体体积，那就可以装进背包里。每个物体都有两个属性，即体积w和价值v。<br>问：如何向背包装物体才能使背包中物体的总价值最大？</p><p>背包的状态转移方程为<br>$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[j])$</p><p>i代表对i件物体做决策，有两种方式—放入背包和不放入背包。<br>j表示当前背包剩余的容量。</p><p>转移方程的解释：<br>创建一个状态矩阵dp，横坐标 i 是物体编号，纵坐标 j 为背包容量。<br>首先将整个dp初始化为0，这个表示不放物体时最大价值为0 。（物体编号从1开始）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>            <span class="hljs-keyword">if</span>(j&gt;=w[i])<span class="hljs-comment">//如果背包装得下</span><br>             dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j-w[i]]+v[i]);<br>            <span class="hljs-keyword">else</span><br>             dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>背包问题的优化（空间复杂度）：<br>（1）状态表dp的遍历顺序为从第1行开始一行一行遍历，且在遍历第i行时候不会用到第i-2行数据，也就是i-2行及以前的数据没有用了，可以清除。同时，第i-1行的数据每个只会用到一次。<br>（2）遍历每一行时候只用到当前容量j和j-w[i]的数据，也就是第 i 次遍历只需要第 i-1 次遍历中容量小于等于 j 的数据。<br>（3）把遍历第i个物体和遍历第i-1个物体时的最大价值存在一个单元里。更新前f[j]存i-1的价值，更新后f[j]存i的价值。因为用不到i-2及以前的数据所以不需要存。因为以后不会再用到i-1的价值所以被覆盖了没问题<br>（4）j从背包容量V开始遍历，即从大到小遍历，保证了当前dp[j]和dp[j - w[i]]里面存的是i-1的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= w[i]; j--)<br>    &#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-矩阵连乘问题"><a href="#3-矩阵连乘问题" class="headerlink" title="3. 矩阵连乘问题"></a>3. <strong>矩阵连乘问题</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dpmax[<span class="hljs-number">305</span>][<span class="hljs-number">305</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dpmin[<span class="hljs-number">305</span>][<span class="hljs-number">305</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">405</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">+1</span>;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=n;j++)&#123;<br>            dpmin[i][j]=<span class="hljs-number">0x7f7f7f7f7f7f7f</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++)&#123;<br>                dpmax[i][j]=<span class="hljs-built_in">max</span>(dpmax[i][j],dpmax[i][k]+dpmax[k<span class="hljs-number">+1</span>][j]+a[i]*a[k<span class="hljs-number">+1</span>]*a[j<span class="hljs-number">+1</span>]);<br>                dpmin[i][j]=<span class="hljs-built_in">min</span>(dpmin[i][j],dpmin[i][k]+dpmin[k<span class="hljs-number">+1</span>][j]+a[i]*a[k<span class="hljs-number">+1</span>]*a[j<span class="hljs-number">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4lf&quot;</span>,(<span class="hljs-type">double</span>)dpmax[<span class="hljs-number">1</span>][n]/dpmin[<span class="hljs-number">1</span>][n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-最长公共子串和最长公共子序列"><a href="#4-最长公共子串和最长公共子序列" class="headerlink" title="4. 最长公共子串和最长公共子序列"></a>4. <strong>最长公共子串和最长公共子序列</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br><span class="hljs-type">int</span> dp2[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-type">char</span> S1[<span class="hljs-number">2001</span>], S2[<span class="hljs-number">2001</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, S1, S2);<br>        <span class="hljs-type">int</span> len1 = <span class="hljs-built_in">strlen</span>(S1);<br>        <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">strlen</span>(S2);<br>      <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len1; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            dp2[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= len2; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            dp2[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; j++) &#123;<br>                <span class="hljs-keyword">if</span> (S1[i<span class="hljs-number">-1</span>] == S2[j<span class="hljs-number">-1</span>]) &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                maxLen = <span class="hljs-built_in">MAX</span>(maxLen, dp[i][j]);<br>                dp2[i][j] = <span class="hljs-built_in">MAX</span>(dp2[i<span class="hljs-number">-1</span>][j], dp2[i][j<span class="hljs-number">-1</span>]);<br>                <span class="hljs-keyword">if</span> (S1[i<span class="hljs-number">-1</span>] == S2[j<span class="hljs-number">-1</span>]) &#123;<br>                    dp2[i][j] = <span class="hljs-built_in">MAX</span>(dp2[i][j], dp2[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, maxLen, dp2[len1][len2]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>最长单调子序列</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 严格单调递增子列的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lsrsa</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sa;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;<br>        <span class="hljs-keyword">if</span> (sa.<span class="hljs-built_in">empty</span>() || x &gt; sa.<span class="hljs-built_in">back</span>())<br>            sa.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">else</span><br>            *<span class="hljs-built_in">lower_bound</span>(sa.<span class="hljs-built_in">begin</span>(), sa.<span class="hljs-built_in">end</span>(), x) = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) sa.<span class="hljs-built_in">size</span>();<br>&#125;<br><span class="hljs-comment">// 单调不减子列的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lrsa</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sa;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;<br>        <span class="hljs-keyword">if</span> (sa.<span class="hljs-built_in">empty</span>() || x &gt;= sa.<span class="hljs-built_in">back</span>())<br>            sa.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">else</span><br>            *<span class="hljs-built_in">upper_bound</span>(sa.<span class="hljs-built_in">begin</span>(), sa.<span class="hljs-built_in">end</span>(), x) = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) sa.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图算法</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><h3 id="基本图算法"><a href="#基本图算法" class="headerlink" title="基本图算法"></a>基本图算法</h3><h4 id="1-广搜-bfs"><a href="#1-广搜-bfs" class="headerlink" title="1. 广搜(bfs)"></a>1. 广搜(bfs)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">bool</span>&gt; visited;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    visited[start] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; node &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[node].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> next = graph[node][i];<br>            <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>                q.<span class="hljs-built_in">push</span>(next);<br>                visited[next] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 输入图的节点数和边数</span><br>    graph.<span class="hljs-built_in">resize</span>(n);<br>    visited.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 输入边的两个节点</span><br>        graph[u].<span class="hljs-built_in">push_back</span>(v);<br>        graph[v].<span class="hljs-built_in">push_back</span>(u); <span class="hljs-comment">// 无向图需要加上这一行</span><br>    &#125;<br>    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 从节点0开始广度优先搜索</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-深搜-dfs"><a href="#2-深搜-dfs" class="headerlink" title="2. 深搜(dfs)"></a>2. 深搜(dfs)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">bool</span>&gt; visited;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>    cout &lt;&lt; node &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    visited[node] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[node].<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> next = graph[node][i];<br>        <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>            <span class="hljs-built_in">dfs</span>(next);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 输入图的节点数和边数</span><br>    graph.<span class="hljs-built_in">resize</span>(n);<br>    visited.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 输入边的两个节点</span><br>        graph[u].<span class="hljs-built_in">push_back</span>(v);<br>        graph[v].<span class="hljs-built_in">push_back</span>(u); <span class="hljs-comment">// 无向图需要加上这一行</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 从节点0开始深度优先搜索</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3. 拓扑排序"></a>3. 拓扑排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> indegree[<span class="hljs-number">200005</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt;p[<span class="hljs-number">400005</span>];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topological_sort</span><span class="hljs-params">()</span></span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; dot;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(indegree[i]==<span class="hljs-number">0</span>)&#123;<br>            dot.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!dot.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> v=dot.<span class="hljs-built_in">top</span>();<br>        dot.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-type">int</span> size=p[v].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            indegree[p[v][i]]--;<br>            <span class="hljs-keyword">if</span>(indegree[p[v][i]]==<span class="hljs-number">0</span>)&#123;<br>                dot.<span class="hljs-built_in">push</span>(p[v][i]);<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><h4 id="1-dijkstra求单源最短路径"><a href="#1-dijkstra求单源最短路径" class="headerlink" title="1. dijkstra求单源最短路径"></a>1. <strong>dijkstra求单源最短路径</strong></h4><p><strong>原理是广搜加dp</strong><br>时间复杂度是$O(mlogm)$<br><em>每次使用时记得将<code>dist</code>的元素均置为<code>LLONG_MAX</code>,一般用于带权有向图，且权值无负数</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">graph</span>(n<span class="hljs-number">+2</span>);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; graph, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>    graph[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dist[<span class="hljs-number">305</span>][<span class="hljs-number">305</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <br>    dist[start][start] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, start&#125;);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = pq.<span class="hljs-built_in">top</span>().second;<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> edge : graph[u]) &#123;<br>            <span class="hljs-type">int</span> v = edge.first;<br>            <span class="hljs-type">int</span> w = edge.second;<br>            <span class="hljs-keyword">if</span> (dist[start][u] + w &lt; dist[start][v]) &#123;<br>                dist[start][v] = dist[start][u] + w;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[start][v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Floyd-Warshall算法求所有结点最短路径"><a href="#2-Floyd-Warshall算法求所有结点最短路径" class="headerlink" title="2. Floyd-Warshall算法求所有结点最短路径"></a>2. <strong>Floyd-Warshall算法求所有结点最短路径</strong></h4><p>时间复杂度为$O(n^3)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure><p>状态表示：我们用$d [ k , i , j ]$表示从i走到j，且中间经过的点的编号不超过k的所有路径长度的最小值，什么叫做中间经过点的编号不超过k呢？假设i到j中间经过所有点为$a_1 , a_2 , . . . ,a_m$</p><p>​<br> ，那么这m个点的编号值都$&lt;&#x3D; k$ ，注意不要与总共经过不超过k个点混淆。</p><p>状态计算：$d [ k , i , j ]$的计算可以分为两类：</p><p>从i走到j，且中间经过的点的编号不超过k且不包含k的所有节点路径：那么它就等价于从i走到j且经过的点的编号不超过k - 1的所有路径的最小值，即$d [ k − 1 , i , j ]$</p><p>从i走到j，且中间经过的点的编号不超过k且包含k的所有节点路径：那么我们就会发现，它一定会从i走到k，并且一定会从k走到j，因此我们可以将它分为两段之和：</p><p>从i走到k，且中间经过的点的编号不超过k - 1的所有节点路径的最小值，即$d [ k − 1 , i , k ] $<br>从k走到j，且中间经过的点的编号不超过k - 1的所有节点路径的最小值，即$d [ k − 1 , k , j ] $<br>并且前后两段是没有关系的，所以这种情况的表示就是$d [k − 1 ,i, k ] + d [ k − 1 , k , j ] $</p><p>因此，我们可以得出$d [ k , i , j ] &#x3D; m i n ( d [ k − 1 , i , j ] , d [k − 1 , i , k ] + d [ k − 1 , k , j ] ) $</p><p>$&#x3D; min(d[k - 1,i,j],d[k - 1,i,k] + d[k - 1,k,j])d[k,i,j]&#x3D;min(d[k−1,i,j],d[k−1,i,k]+d[k−1,k,j])$</p><h3 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3. 最小生成树"></a>3. <strong>最小生成树</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 300005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 500005</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> x, y, w;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp;b) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> w &lt; b.w; &#125;<br>&#125; e[E_MAX];<br><br><span class="hljs-type">int</span> v[V_MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">//合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">//初始化并查集</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">makeSet</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        cin &gt;&gt; e[i].x &gt;&gt; e[i].y &gt;&gt; e[i].w;<br>    <span class="hljs-built_in">sort</span>(e, e + m);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; cnt &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isUnion</span>(e[i].x, e[i].y))<br>            <span class="hljs-keyword">continue</span>;<br>        cnt++;<br>        sum += e[i].w;<br>        <span class="hljs-built_in">Union</span>(e[i].x, e[i].y);<br>    &#125;<br>    cout &lt;&lt; sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        v[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (v[x] == x)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> v[x] = <span class="hljs-built_in">Find</span>(v[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(x) == <span class="hljs-built_in">Find</span>(y); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; v[<span class="hljs-built_in">Find</span>(y)] = <span class="hljs-built_in">Find</span>(x); &#125;<br><br></code></pre></td></tr></table></figure><h3 id="流网络问题"><a href="#流网络问题" class="headerlink" title="流网络问题"></a>流网络问题</h3><h4 id="1-最大流dinic算法"><a href="#1-最大流dinic算法" class="headerlink" title="1.最大流dinic算法"></a>1.<strong>最大流dinic算法</strong></h4><p><strong>流网络中的增广路</strong>是指：从源节点到汇点的一条路径，并且在这条路径上还存在可以增加流量的余地。这条路径上的残余容量（即路径上各边的剩余容量）都大于 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">150</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">5050</span>;<br><span class="hljs-type">int</span> h[N],idx=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> n,m,s,t;<span class="hljs-comment">//s代表源点，t代表汇点</span><br><span class="hljs-comment">//数组h存i点的最后一条出边的编号，便于点i的所有出边的遍历,idx图中代表所有出边的编号 </span><br><span class="hljs-type">int</span> d[N],cur[N];<br><span class="hljs-comment">//数组d代表图的层数，cur存在dfs时，u当前的出边编号，因为已经遍历过的边不存在新的增广路径 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br> <span class="hljs-type">int</span> v;<span class="hljs-comment">//出边的终点 </span><br> <span class="hljs-type">long</span> <span class="hljs-type">long</span> w;<span class="hljs-comment">//出边的容量 </span><br> <span class="hljs-type">int</span> ne;<span class="hljs-comment">//1个点的第n条出边存第n-1条出边的编号 </span><br>&#125;e[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>&#123;<br> e[++idx]=&#123;v,w,h[u]&#125;;<br> h[u]=idx;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> d);<br> queue&lt;<span class="hljs-type">int</span>&gt;q;<br> q.<span class="hljs-built_in">push</span>(s);<span class="hljs-comment">//s代表源点 </span><br> d[s]=<span class="hljs-number">1</span>;<span class="hljs-comment">//源点在第一层 </span><br> <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>  <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">0</span>;i=e[i].ne)&#123;<br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(d[v]==<span class="hljs-number">0</span>&amp;&amp;e[i].w)&#123;<br>            d[v]=d[u]<span class="hljs-number">+1</span>; <br>            q.<span class="hljs-built_in">push</span>(v);<br>            <span class="hljs-keyword">if</span>(v==t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//说明找到了从源点到汇点的增广路径 </span><br>        &#125;<span class="hljs-comment">//v如果还没分层，且该出边的剩余容量不为0 </span><br>    &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">long</span> <span class="hljs-type">long</span> mf)</span></span>&#123;<span class="hljs-comment">//mf代表可以从u点流出的剩余流量 </span><br> <span class="hljs-keyword">if</span>(u==t) <span class="hljs-keyword">return</span> mf;<span class="hljs-comment">//如果已经到达汇点，返回mf；</span><br> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;<span class="hljs-comment">//u点的总流出量的最大值 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">0</span>;i=e[i].ne)&#123;<br>        cur[u]=i;<span class="hljs-comment">//记录当前的弧，减少总遍历次数</span><br>        <span class="hljs-type">int</span> v=e[i].v;<br>        <span class="hljs-keyword">if</span>(d[v]==d[u]<span class="hljs-number">+1</span>&amp;&amp;e[i].w)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> f=<span class="hljs-built_in">dfs</span>(v,<span class="hljs-built_in">min</span>(mf,e[i].w));<br>            e[i].w-=f;<br>            sum+=f; <br>            mf-=f;<br>            <span class="hljs-keyword">if</span>(mf==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果u点没有可以流出的流量了，结束循环 </span><br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>) d[u]=<span class="hljs-number">0</span>;<span class="hljs-comment">//sum=0代表u点无法到达汇点，该点标记为-1层，直接排除循环</span><br>    <span class="hljs-keyword">return</span> sum; <br>&#125; <span class="hljs-comment">//dfs的作用是求从u点流出的最大流量值。 </span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())&#123;<span class="hljs-comment">//如果存在增广路，就继续搜</span><br>            <span class="hljs-built_in">memcpy</span>(cur,h,<span class="hljs-keyword">sizeof</span> h);<br>            flow+=<span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">1e13</span>);<br>        &#125;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-最大二分匹配"><a href="#2-最大二分匹配" class="headerlink" title="2.最大二分匹配"></a>2.<strong>最大二分匹配</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">405</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; graph[MAXN];<br><span class="hljs-type">int</span> match[MAXN];<br><span class="hljs-type">bool</span> visited[MAXN];<br><br><span class="hljs-comment">//寻找增广路径 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>            visited[v] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[v] == <span class="hljs-number">-1</span>||<span class="hljs-built_in">dfs</span>(match[v])) &#123;<br>                match[v] = u;<span class="hljs-comment">//直到找到未饱和点</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//最大二分匹配 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxMatching</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(match, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(match));<span class="hljs-comment">//先初始化所有点未匹配 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(visited, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(visited));<span class="hljs-comment">//深搜点标记 </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i)) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算几何</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="1-求凸包"><a href="#1-求凸包" class="headerlink" title="1. 求凸包"></a>1. 求凸包</h3><p><strong>Graham扫描法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以左下点为极点求凸包周长</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;<br>    <span class="hljs-type">double</span> x,y;<br>    point <span class="hljs-keyword">friend</span> <span class="hljs-keyword">operator</span> -(point a,point b)<br>    &#123;<span class="hljs-keyword">return</span> &#123;a.x-b.x,a.y-b.y&#125;;&#125;<br>&#125;p[<span class="hljs-number">105</span>],s[<span class="hljs-number">105</span>];<span class="hljs-comment">//p为所有点的集合,s为凸包点集</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(point a,point b)</span></span><br><span class="hljs-function"></span>&#123;<br>    point c=a-b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(c.x*c.x+c.y*c.y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(point a,point b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.x*b.y-a.y*b.x;<br>&#125;<br><span class="hljs-comment">//按照极角(polar angle)从小到大排序(以 p1为极点)</span><br><span class="hljs-comment">//极角相同的点按照到的距离从小到大排序。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(point a,point b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x=<span class="hljs-built_in">cross</span>(a-p[<span class="hljs-number">1</span>],b-p[<span class="hljs-number">1</span>]);<br> <br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">dis</span>(a,p[<span class="hljs-number">1</span>])&lt;<span class="hljs-built_in">dis</span>(b,p[<span class="hljs-number">1</span>])) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">multi</span><span class="hljs-params">(point p1,point p2,point p3)</span><span class="hljs-comment">//计算向量叉积</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">cross</span>(p2-p1,p3-p1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N),N)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y;<br> <br>        <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.00\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(N==<span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,<span class="hljs-built_in">dis</span>(p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>]));<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)<br>        <span class="hljs-keyword">if</span>(p[i].y&lt;p[k].y||(p[i].y==p[k].y&amp;&amp;p[i].x&lt;p[k].x))k=i;<br>        <span class="hljs-built_in">swap</span>(p[<span class="hljs-number">1</span>],p[k]);<span class="hljs-comment">//找到处于最左下方的点,赋给p[1]</span><br> <br>        <span class="hljs-built_in">sort</span>(p<span class="hljs-number">+2</span>,p<span class="hljs-number">+1</span>+N,cmp);<span class="hljs-comment">//对点按极角排序,p[1]为极点</span><br> <br>        s[<span class="hljs-number">1</span>]=p[<span class="hljs-number">1</span>];<br>        s[<span class="hljs-number">2</span>]=p[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//while循环把发现不是凸包顶点的点移除出去,因为当逆时针遍历凸包时，我们应该在每个顶点向左转</span><br>        <span class="hljs-comment">//因此当while循环发现在一个顶点处没有向左转时，就把该顶点移除出去。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=N;i++)<span class="hljs-comment">//求凸包</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>(cnt&gt;=<span class="hljs-number">2</span>&amp;&amp;<span class="hljs-built_in">multi</span>(s[cnt<span class="hljs-number">-1</span>],s[cnt],p[i])&lt;=<span class="hljs-number">0</span>) cnt--;<br>            s[++cnt]=p[i];<br>        &#125;<br>        <span class="hljs-type">double</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;cnt;i++)<span class="hljs-comment">//求凸包周长</span><br>            sum+=<span class="hljs-built_in">dis</span>(s[i],s[i<span class="hljs-number">+1</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,sum+<span class="hljs-built_in">dis</span>(s[<span class="hljs-number">1</span>],s[cnt]));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        double area=0;</span><br><span class="hljs-comment">        for(int i=2;i&lt;=cnt-1;i++)//求凸包面积，这里因为就是凸多边形所以可以用某个顶点作为顶点分割三角形</span><br><span class="hljs-comment">            area+=fabs(multi(s[1],s[i],s[i+1]));</span><br><span class="hljs-comment">        printf(&quot;%d\n&quot;,int(area/100));</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">/*标准求多边形面积,别漏了最后一个和起点的叉积</span><br><span class="hljs-comment">        for(int i=1;i&lt;=cnt;i++)//求凸包面积</span><br><span class="hljs-comment">            area+=cross(s[i],s[i==cnt?1:i+1]);</span><br><span class="hljs-comment">        if(area&lt;0)</span><br><span class="hljs-comment">            area=-area;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分治法：求解上凸包和下图包合并</strong></p><ol><li>按横坐标从小到大（再总坐标从小到大）排序，首先排序后的起终点必然在凸包里</li><li>连接p1pn，这条直线将点集分成了上下两个部分，则在这两个部分中分别求得上、下凸包</li><li>对于上凸包，找到上部分离直线最远的点pmax,连接p1max,pmaxpn，则直线p1pmax右将上部分分成了两个凸包部分</li><li>重复，求下凸包类似</li><li>判断点位于直线的左侧还是右侧可以用叉积</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//求能围住所有的点且距离所有点的距离&gt;=L的围墙的长度</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">double</span> x, y;<br><br>    Point <span class="hljs-keyword">operator</span>-(Point &amp; p)<br>    &#123;<br>        Point t;<br>        t.x = x - p.x;<br>        t.y = y - p.y;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(Point p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x*p.y - p.x*y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(Point &amp; p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x - p.x)*(x - p.x) + (y - p.y)*(y - p.y));<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point p1, Point p2)</span><span class="hljs-comment">//先横坐标从小到大,再纵坐标从小到大</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p<span class="hljs-number">1.</span>x != p<span class="hljs-number">2.</span>x)<br>        <span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>x &lt; p<span class="hljs-number">2.</span>x;<br>    <span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>y &lt; p<span class="hljs-number">2.</span>y;<br>&#125;<br> <br>Point point[<span class="hljs-number">1005</span>];<br><span class="hljs-type">int</span> convex[<span class="hljs-number">1005</span>];<br><span class="hljs-type">int</span> N, L;<br> <br><span class="hljs-comment">//返回极点个数+1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getConvexHull</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(point, point + N, cmp);<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<span class="hljs-comment">//求解下凸包,&lt;=关系则如果存在共线的点只取端点</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (total &gt; <span class="hljs-number">1</span> &amp;&amp; (point[convex[total - <span class="hljs-number">1</span>]] - point[convex[total - <span class="hljs-number">2</span>]]).<span class="hljs-built_in">cross</span>(point[i] - point[convex[total - <span class="hljs-number">1</span>]]) &lt;= <span class="hljs-number">0</span>)<br>            total--;<br>        convex[total++] = i;<br>    &#125;<br>    <span class="hljs-comment">//求解上凸包</span><br>    temp = total;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (total &gt; temp &amp;&amp; (point[convex[total - <span class="hljs-number">1</span>]] - point[convex[total - <span class="hljs-number">2</span>]]).<span class="hljs-built_in">cross</span>(point[i] - point[convex[total - <span class="hljs-number">1</span>]]) &lt;= <span class="hljs-number">0</span>)<br>            total--;<br>        convex[total++] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> total;<span class="hljs-comment">//返回组成凸包的点的个数，实际上多了一个,是起点(开始与最后都是起点),所以组成凸包的点个数是total-1</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;L);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>, &amp;point[i].x, &amp;point[i].y);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">getConvexHull</span>();<br>    <span class="hljs-type">double</span> ans = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num - <span class="hljs-number">1</span>; i++)<br>        ans += point[convex[i]].<span class="hljs-built_in">dist</span>(point[convex[i + <span class="hljs-number">1</span>]]);<br>    ans += <span class="hljs-number">3.14159265358927</span> * <span class="hljs-number">2</span> * L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.0f\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="2-判断线段关系"><a href="#2-判断线段关系" class="headerlink" title="2. 判断线段关系"></a><strong>2. 判断线段关系</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">double</span> x, y;<br>&#125;;<br><br><span class="hljs-comment">//算叉乘</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(Point A, Point B, Point C)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_intersect</span><span class="hljs-params">(Point A, Point B, Point C, Point D)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(A.x, B.x) &lt;= <span class="hljs-built_in">max</span>(C.x, D.x) &amp;&amp;<br>        <span class="hljs-built_in">min</span>(C.x, D.x) &lt;= <span class="hljs-built_in">max</span>(A.x, B.x) &amp;&amp;<br>        <span class="hljs-built_in">min</span>(A.y, B.y) &lt;= <span class="hljs-built_in">max</span>(C.y, D.y) &amp;&amp;<br>        <span class="hljs-built_in">min</span>(C.y, D.y) &lt;= <span class="hljs-built_in">max</span>(A.y, B.y) &amp;&amp;<br>        <span class="hljs-built_in">cross</span>(A, B, C) * <span class="hljs-built_in">cross</span>(A, B, D) &lt;= <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-built_in">cross</span>(C, D, A) * <span class="hljs-built_in">cross</span>(C, D, B) &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_para</span><span class="hljs-params">(Point A, Point B, Point C, Point D)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (B.y-A.y)*(D.x-C.x)==(B.x-A.x)*(D.y-C.y);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-旋转卡壳求凸包直径"><a href="#3-旋转卡壳求凸包直径" class="headerlink" title="3. 旋转卡壳求凸包直径"></a><strong>3. 旋转卡壳求凸包直径</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">200005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-7</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br><br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;<br>    &#125;<br><br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;<br>    &#125;<br><br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (x != b.x)<br>            <span class="hljs-keyword">return</span> x &lt; b.x;<br>        <span class="hljs-keyword">return</span> y &lt; b.y;<br>    &#125;<br>&#125;;<br><br>Point p[MAX];<br>Point s[MAX];<br><span class="hljs-type">int</span> top;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">s_sqr</span><span class="hljs-params">(Point a, Point b, Point c)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">diameter</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;<br>    <span class="hljs-built_in">selMin</span>(n);<br>    <span class="hljs-built_in">sort</span>(p + <span class="hljs-number">1</span>, p + n, cmp);<br>    <span class="hljs-built_in">graham</span>(n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f&quot;</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">diameter</span>())) ;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    Point Min = p[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> IDMin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span> (p[i] &lt; Min) &#123;<br>            Min = p[i];<br>            IDMin = i;<br>        &#125;<br>    <span class="hljs-built_in">swap</span>(p[<span class="hljs-number">0</span>], p[IDMin]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = (a - p[<span class="hljs-number">0</span>]) ^ (b - p[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">equal</span>(x, <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">dis</span>(a, p[<span class="hljs-number">0</span>]) &lt; <span class="hljs-built_in">dis</span>(b, p[<span class="hljs-number">0</span>])))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = a.x - b.x;<br>    <span class="hljs-type">double</span> y = a.y - b.y;<br>    <span class="hljs-keyword">return</span> x * x + y * y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    top = <span class="hljs-number">1</span>;<br>    s[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>];<br>    s[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; ((p[i] - s[top]) ^ (s[top - <span class="hljs-number">1</span>] - s[top])) &lt;= <span class="hljs-number">0</span>)<br>            top--;<br>        s[++top] = p[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">s_sqr</span><span class="hljs-params">(Point a, Point b, Point c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>((a - b) ^ (c - b));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">diameter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> diam = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;<br>    s[++top] = s[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (top &lt; <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dis</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">s_sqr</span>(s[i], s[i + <span class="hljs-number">1</span>], s[j]) &lt;<br>               <span class="hljs-built_in">s_sqr</span>(s[i], s[i + <span class="hljs-number">1</span>], s[(j + <span class="hljs-number">1</span>) % top]))<br>            j = (j + <span class="hljs-number">1</span>) % top;<br>        diam = <span class="hljs-built_in">max</span>(diam, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dis</span>(s[i], s[j]), <span class="hljs-built_in">dis</span>(s[i + <span class="hljs-number">1</span>], s[j])));<br>    &#125;<br>    <span class="hljs-keyword">return</span> diam;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; eps;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式和快速傅里叶变换</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="多项式和快速傅里叶变换"><a href="#多项式和快速傅里叶变换" class="headerlink" title="多项式和快速傅里叶变换"></a>多项式和快速傅里叶变换</h2><h3 id="FFT算法"><a href="#FFT算法" class="headerlink" title="FFT算法"></a>FFT算法</h3><p>多项式用点值表示</p><p>首先设一个多项式 $A(x)$</p><p>$A(x)&#x3D;\sum_{i&#x3D;0}^{n-1}a_ix^i&#x3D;a_0+a_1x+a_2x^2+…+a_{n-1}x^{n-1}$</p><p>按$A(x)$下标的奇偶性把 $A(x)$ 分成两半，右边再提一个$x$</p><p>${A(x)&#x3D;(a_0+a_2x^2+…+a_{n-2}x^{n-2})+(a_1x+a_3x^3+…+a_{n-1}x^{n-1})}$<br>${&#x3D;(a_0+a_2x^2+…+a_{n-2}x^{n-2})+x(a_1+a_3x^2+…+a_{n-1}x^{n-2})}$</p><p>两边好像非常相似，于是再设两个多项式 $A_1(x),A_2(x)$，令</p><p>$A_1(x)&#x3D;a_0+a_2x+a_4x^2+…+a_{n-2}x^{​{n \over 2}-1}$</p><p>$A_2(x)&#x3D;a_1+a_3x+a_5x^2+…+a_{n-1}x^{​{n \over 2}-1}$</p><p>比较明显得出</p><p>$A(x)&#x3D;A_1(x^2)+xA_2(x^2)$</p><p>单位根：<br>$\omega_n^k&#x3D;\cos{k\over n}2\pi +i\sin{k\over n} 2\pi$<br>再设 $k&lt; {n\over 2}$ ，把 $\omega^k_n$ 作为 $x$ 代入 $A(x)$（接下来几步变换要多想想单位根的性质）</p><p>$A(\omega^k_n)$<br>$&#x3D;A_1( (\omega^k_n)^2 )+\omega^k_nA_2( ( \omega^k_n)^2 )$<br>$&#x3D;A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})$<br>$&#x3D;A_1( \omega^k_{n\over2} )+\omega^k_nA_2( \omega^k_{n \over 2} )$</p><p>那么对于${A(\omega^{k+{n\over2}}_n)}$的话，代入<br>${\omega^{k+{n \over 2}}_n}$</p><p>$A(\omega^{k+{n\over 2}}_n)&#x3D;A_1(\omega^{2k+n}_n)+\omega^{k+{n\over 2}}_nA_2(\omega^{2k+n}_n)$</p><p>$&#x3D;A_1(\omega^{2k}_n\omega^n_n)-\omega^k_nA_2(\omega^{2k}_n\omega^n_n)$</p><p>$&#x3D;A_1( \omega_n^{2k} )-\omega_n^kA_2(\omega_n^{2k})$</p><p>$&#x3D;A_1( \omega_{n \over 2}^k )-\omega^k_nA_2(\omega_{n \over 2}^k)$</p><p>如果已知 $A_1(\omega^k_{n\over 2})和 A_2(\omega^k_{n\over 2})$的值，我们就可以同时知道 $A(\omega^k_n)$和 $A(\omega^{k+{n\over2}}_n)$的值</p><p>现在我们就可以递归分治来搞 FFT 了</p><h3 id="FFT逆变换"><a href="#FFT逆变换" class="headerlink" title="FFT逆变换"></a>FFT逆变换</h3><p><strong>一个多项式在分治的过程中乘上单位根的共轭复数（即$\omega_n^k&#x3D;\cos{k\over n}2\pi-i\sin{k\over n} 2\pi$），分治完的每一项除以 n 即为原多项式的每一项系数</strong></p><p><strong>注意，fft只能处理$2^k$的项，所以每次fft前，需要找到相乘后大于最高系数的最小的$2^k$作为limit</strong></p><p><strong>递归版</strong><br>时间复杂度为$nlogn$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">18</span>)<span class="hljs-number">+100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span>&#123;<br> <span class="hljs-type">double</span> x, y;<br> <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> xx = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> yy = <span class="hljs-number">0</span>)&#123;x = xx, y = yy;&#125;<br>&#125;a[N];<br>Complex <span class="hljs-keyword">operator</span> + (Complex a, Complex b)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.x + b.x, a.y + b.y);&#125;<br>Complex <span class="hljs-keyword">operator</span> - (Complex a, Complex b)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.x - b.x, a.y - b.y);&#125;<br>Complex <span class="hljs-keyword">operator</span> * (Complex a, Complex b)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(<span class="hljs-type">int</span> limit, Complex *a, <span class="hljs-type">int</span> type)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(limit == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid=limit&gt;&gt;<span class="hljs-number">1</span>;<br>        Complex* a1=(Complex *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Complex)*mid);<br>        Complex* a2=(Complex *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Complex)*mid);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;limit; i += <span class="hljs-number">2</span>) &#123;<br>            a1[i &gt;&gt; <span class="hljs-number">1</span>] = a[i];<br>            a2[i &gt;&gt; <span class="hljs-number">1</span>] = a[i + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-built_in">fft</span>(mid, a1, type);<span class="hljs-comment">//type为1时是系数转点值，即正变换，-1时是点值转系数，即逆变换</span><br>        <span class="hljs-built_in">fft</span>(mid, a2, type);<br>        Complex Wn = <span class="hljs-built_in">Complex</span>(<span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span> * pi / limit), type * <span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span> * pi / limit)), w = <span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid; i++, w = w * Wn)&#123;<br>            a[i] = a1[i] + w * a2[i];<br>            a[i + (limit &gt;&gt; <span class="hljs-number">1</span>)] = a1[i] - w * a2[i];<br>        &#125;<br>        <span class="hljs-built_in">free</span>(a1);<br>        <span class="hljs-built_in">free</span>(a2);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>非递归版（效率高，但是难理解）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span>&#123;<br>    <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> xx = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> yy = <span class="hljs-number">0</span>)&#123;x = xx, y = yy;&#125;<br>&#125;a[N],b[N];<br><br><span class="hljs-type">int</span> rev[N*<span class="hljs-number">2</span>];<br><br>Complex <span class="hljs-keyword">operator</span> + (Complex a, Complex b)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.x + b.x, a.y + b.y);&#125;<br>Complex <span class="hljs-keyword">operator</span> - (Complex a, Complex b)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.x - b.x, a.y - b.y);&#125;<br>Complex <span class="hljs-keyword">operator</span> * (Complex a, Complex b)&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;<br><br><span class="hljs-type">int</span> limit=<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(Complex *a, <span class="hljs-type">int</span> type)</span></span>&#123;<br>    Complex Wn, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; limit; i++)&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; rev[i]) <span class="hljs-built_in">swap</span>(a[i], a[rev[i]]);<span class="hljs-comment">//得到后序列，i &lt; rev[i] 是保证只交换一次 </span><br>    &#125; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> mid = <span class="hljs-number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//mid 是每次要处理序列长度的一半 </span><br>    Wn = Complex&#123;<span class="hljs-built_in">cos</span>(pi / mid), type * <span class="hljs-built_in">sin</span>(pi / mid)&#125;;<span class="hljs-comment">//得到单位根，角度是 2 * pi / 2 * mid， 2被约掉了 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> R = (mid &lt;&lt; <span class="hljs-number">1</span>), j = <span class="hljs-number">0</span>; j &lt; limit; j += R)&#123;<span class="hljs-comment">//枚举序列左端点 </span><br>            w = Complex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//得到单位根的 0 次方 </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; mid; k++, w = w * Wn)&#123;<span class="hljs-comment">//j + k是在序列中的位置，同时得到单位根的 k 次方 </span><br>                Complex x = a[j + k], y = a[j + mid + k] * w;<span class="hljs-comment">//由单位根的性质(1),(2) 推导而来 </span><br>                a[j + k] = x + y;<br>                a[j + mid + k] = x - y;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="1-kmp算法"><a href="#1-kmp算法" class="headerlink" title="1. kmp算法"></a>1. <strong>kmp算法</strong></h3><p>核心是对next数组的构建。<br>next[j]表示，在B[0]-B[j]所组成的这个子串中最长公共真前后缀的长度为x，通俗地说，若next[j]的值为x，则说明这个（B[0]-B[j]所组成的）子串的前x个字符和后x个字符相同。</p><p>时间复杂度为$O(n+m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1e5</span>;<br><br><span class="hljs-type">char</span> s[MAXN],t[MAXN];<span class="hljs-comment">//s是模式串，t是被匹配串 </span><br><span class="hljs-type">int</span> nxt[MAXN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span> s[],<span class="hljs-type">char</span> t[])</span></span>&#123;<br><br>    <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(s),m=<span class="hljs-built_in">strlen</span>(t);<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> j=nxt[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=s[j])&#123;<br>                j=nxt[j<span class="hljs-number">-1</span>];<br>        &#125;<span class="hljs-comment">//递推思维找nxt[i]</span><br>        <span class="hljs-keyword">if</span>(s[i]==s[j])&#123;<br>            nxt[i]=j<span class="hljs-number">+1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            nxt[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;t[i]!=s[j])&#123;<br>            j=nxt[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t[i]==s[j])&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n)<br>        &#123;<br>            <span class="hljs-type">int</span> ans = i - j + <span class="hljs-number">1</span>;<br>            j = nxt[j<span class="hljs-number">-1</span>];<span class="hljs-comment">//匹配成功 </span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-有限自动机匹配"><a href="#2-有限自动机匹配" class="headerlink" title="2. 有限自动机匹配"></a>2. <strong>有限自动机匹配</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Matching_Prefix_Suffix</span><span class="hljs-params">(<span class="hljs-type">char</span>* P,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> q,<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;                               <span class="hljs-comment">//P为模式串 K为要验证的前缀和后缀的字符串长度</span><br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)                    <span class="hljs-comment">//q为当前自动机主线长度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;              <span class="hljs-comment">//k=0 空字符串 前缀和后缀肯定相等</span><br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;                <span class="hljs-comment">//只有一个字符串 证明自动机刚好开始创建</span><br>        <span class="hljs-keyword">return</span> P[<span class="hljs-number">0</span>]==c;      <span class="hljs-comment">//如果模式串的第一个和其中的c相等 前缀等于后缀</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> P[k<span class="hljs-number">-1</span>]==c&amp;&amp; (!<span class="hljs-built_in">strncmp</span>(P,P+q-k<span class="hljs-number">+1</span>,k<span class="hljs-number">-1</span>));    <span class="hljs-comment">//检验P[0...k-1]==P[q-k+1...q]</span><br>&#125;<br> <br>vector&lt;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Compute_Transition_Function</span>( <span class="hljs-type">char</span> *P,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* input_character)<br>&#123;                                <span class="hljs-comment">//计算转移函数的值</span><br>    <span class="hljs-type">int</span> m=<span class="hljs-built_in">strlen</span>(P);                <span class="hljs-comment">//模式串的长度</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,k;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The main length of Finite_Automaton_Matcher is %d\n&quot;</span>,m);<br>    vector&lt;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &gt;<span class="hljs-built_in">transition_map</span>(m<span class="hljs-number">+1</span>);         <span class="hljs-comment">//创建一个vector 一共有m+1个数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;                   <span class="hljs-comment">//对于模式串的长度</span><br>        j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(input_character[j]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;      <span class="hljs-comment">//对于输入串的每一种可能字符</span><br>         k= <span class="hljs-built_in">min</span>(m<span class="hljs-number">+1</span>,i<span class="hljs-number">+2</span>);               <span class="hljs-comment">//因为对于长度为i的字符串 它的转移函数最大值为i</span><br>        <span class="hljs-keyword">do</span>&#123;                          <span class="hljs-comment">//数组下标从0开始 再加上后面k一来就减1  所以为i+2</span><br>            k=k<span class="hljs-number">-1</span>;                  <span class="hljs-comment">//找到一个最大值k使得模式串的P[0...k]==P[...n-1]</span><br>    &#125;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">Matching_Prefix_Suffix</span>(P,k,i,input_character[j]));<br>        transition_map[i][input_character[j]]=k;<br>        j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  transition_map;           <span class="hljs-comment">//返回一个vector 每一个元素为 map&lt;char,int&gt;</span><br>&#125;                                     <span class="hljs-comment">//char 为自动机中的字符 int 为转移函数值</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Finite_Automaton_Matcher</span><span class="hljs-params">(<span class="hljs-type">char</span>* T,<span class="hljs-type">char</span>* P,vector&lt;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &gt;transition_map)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(T);                           <span class="hljs-comment">//文本串长度</span><br>    <span class="hljs-type">int</span> m=<span class="hljs-built_in">strlen</span>(P);                           <span class="hljs-comment">//模式串长度</span><br>    <span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;                                   <span class="hljs-comment">//转移函数的值</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;                    <span class="hljs-comment">//对于文本串中的每一个字符</span><br>     q = transition_map[q][T[i]];             <span class="hljs-comment">//迭代 前一个字符的转移函数值</span><br>     <span class="hljs-keyword">if</span>(q==m)                                <span class="hljs-comment">//转移函数的值等于模式串的长度</span><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern occurs with shift %d\n&quot;</span>,i<span class="hljs-number">+1</span>-m);   <span class="hljs-comment">//模式串的有效位移为i-m+1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* input_character=<span class="hljs-string">&quot;abc&quot;</span>;        <span class="hljs-comment">//输入字母表</span><br>    <span class="hljs-type">char</span> T[]=<span class="hljs-string">&quot;abababacaba&quot;</span>;                  <span class="hljs-comment">//文本串</span><br>    <span class="hljs-type">char</span> P[]=<span class="hljs-string">&quot;ababaca&quot;</span>;                      <span class="hljs-comment">//模式串</span><br>    vector&lt;map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &gt;transition_map=<span class="hljs-built_in">Compute_Transition_Function</span>(P,input_character);<br>    <span class="hljs-built_in">Finite_Automaton_Matcher</span>(T,P,transition_map);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-哈希匹配法"><a href="#3-哈希匹配法" class="headerlink" title="3. 哈希匹配法"></a>3. <strong>哈希匹配法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BASE 256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODULUS 101</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RabinKarp</span><span class="hljs-params">(<span class="hljs-type">char</span> t[], <span class="hljs-type">char</span> p[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t_len = <span class="hljs-built_in">strlen</span>(t);<br>    <span class="hljs-type">int</span> p_len = <span class="hljs-built_in">strlen</span>(p);<br><br>    <span class="hljs-comment">// 哈希滚动之用</span><br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p_len - <span class="hljs-number">1</span>; i++)<br>        h = (h * BASE) % MODULUS;<br><br>    <span class="hljs-type">int</span> t_hash = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p_hash = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p_len; i++)<br>    &#123;<br>        t_hash = (BASE * t_hash + t[i]) % MODULUS;<br>        p_hash = (BASE * p_hash + p[i]) % MODULUS;<br>    &#125;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= t_len - p_len)<br>    &#123;<br>         <span class="hljs-comment">// 考虑到哈希碰撞的可能性，还需要用 memcmp 再比对一下</span><br>        <span class="hljs-keyword">if</span> (t_hash == p_hash &amp;&amp; <span class="hljs-built_in">memcmp</span>(p, t + i, p_len) == <span class="hljs-number">0</span>)<br>            cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; is found at index &quot;</span> &lt;&lt; i &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 前缀和思想</span><br>        t_hash = (BASE * (t_hash - t[i] * h) + t[i + p_len]) % MODULUS;<br><br>        <span class="hljs-comment">// 防止出现负数</span><br>        <span class="hljs-keyword">if</span> (t_hash &lt; <span class="hljs-number">0</span>)<br>            t_hash = t_hash + MODULUS;<br><br>        i++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> t[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;It is a test, but not just a test&quot;</span>;<br>    <span class="hljs-type">char</span> p[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;test&quot;</span>;<br><br>    <span class="hljs-built_in">RabinKarp</span>(t, p);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">fast_pow_mod</span><span class="hljs-params">(ll a, ll b, ll m)</span></span>&#123;<br>    a %= m;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % m;<br>        a = a * a % m;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br> <br><span class="hljs-type">int</span> count;<span class="hljs-comment">//排序趟数</span><br><br><span class="hljs-comment">//一些排序需要用到交换 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;<br>    <span class="hljs-type">int</span> temp = *b;<br>    *b = *a;<br>    *a = temp;<br>&#125; <br><br><span class="hljs-comment">//堆排序，adjust是调整函数 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span> k[ ],<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> j,parent;<br>    parent=k[i];<span class="hljs-comment">//注意parent一直没变 </span><br>    j=<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;<span class="hljs-comment">//j是左孩子 </span><br>    <span class="hljs-keyword">while</span>(j&lt;=n)&#123;<br>     count++;<br>        <span class="hljs-keyword">if</span>(j&lt;n&amp;&amp;k[j]&lt;k[j+<span class="hljs-number">1</span>])<br>            j++; <span class="hljs-comment">//j给出i结点左、右孩子中最大值的节点 </span><br>        <span class="hljs-keyword">if</span>(parent&gt;=k[j]) <br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果孩子节点最大值小于根节点，不用交换 </span><br>        k[(j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]=k[j]; <span class="hljs-comment">//把最大的孩子节点移到父节点位置 </span><br>        <br>        j=<span class="hljs-number">2</span>*j+<span class="hljs-number">1</span>;<span class="hljs-comment">//防止交换以后使得子树不是大顶堆，把j看作子树的父节点 </span><br>    &#125;<span class="hljs-comment">//循环结束时 </span><br>    k[(j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]=parent;<span class="hljs-comment">//把父亲节点parent放到最后 </span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(<span class="hljs-type">int</span> k[],<span class="hljs-type">int</span> n)</span>&#123;<br> <span class="hljs-type">int</span> i;<br> <span class="hljs-type">int</span> temp;<br> <span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br> adjust(k,i,n);<span class="hljs-comment">//先从最后一个节点的父节点开始调整，一个个往前推 </span><br> <br> <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>  temp=k[i+<span class="hljs-number">1</span>]; <br>  k[i+<span class="hljs-number">1</span>]=k[<span class="hljs-number">0</span>];<br>  k[<span class="hljs-number">0</span>]=temp;<span class="hljs-comment">//此时根节点破坏了整个树的堆的特性，把根节点放到最后一个节点 </span><br>  adjust(k,<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<span class="hljs-comment">//再对新得到的树进行堆调整 </span><br> &#125;<br>&#125;<br><br><span class="hljs-comment">//堆排序的另一个版本，更加容易理解 </span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n )</span> &#123;<br>    <span class="hljs-comment">//建立父节点指标和子节点指标</span><br>      <span class="hljs-type">int</span> largest = i; <span class="hljs-comment">// 将最大元素设置为堆顶元素</span><br>      <span class="hljs-type">int</span> l = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; <span class="hljs-comment">// left = 2*i + 1</span><br>      <span class="hljs-type">int</span> r = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>; <span class="hljs-comment">// right = 2*i + 2</span><br>  <br>      <span class="hljs-comment">// 如果 left 比 root 大的话</span><br>      <span class="hljs-keyword">if</span> (l &lt;=n &amp;&amp; arr[l] &gt; arr[largest])<br>          largest = l;<br>  <br>      <span class="hljs-comment">// I如果 right 比 root 大的话</span><br>      <span class="hljs-keyword">if</span> (r &lt;=n &amp;&amp; arr[r] &gt; arr[largest])<br>          largest = r;<br>  <br>      <span class="hljs-keyword">if</span> (largest != i) &#123;<br>          swap(&amp;arr[i],&amp;arr[largest]);<br>          <span class="hljs-comment">// 递归地定义子堆</span><br>          max_heapify(arr, n, largest);<br>      &#125;<br> <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//初始化，i从最后一个父节点开始调整</span><br>    <span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        max_heapify(arr, i, len - <span class="hljs-number">1</span>);<br>        <br>    <span class="hljs-comment">//先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕</span><br>    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br>        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//二路归并排序 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeArray</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> head,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> tail)</span><br>&#123;<br> <span class="hljs-comment">//p即为左半部分数组和右半部分数组排序合并后的数组 </span><br> <span class="hljs-type">int</span> i=head,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br> <span class="hljs-type">int</span> *p=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*(tail-head+<span class="hljs-number">1</span>));<br> <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=tail)<br> &#123;<br>  count++;<br>  <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])p[k++]=a[i++];<br>  <span class="hljs-keyword">else</span> p[k++]=a[j++]; <br>  <br> &#125;<span class="hljs-comment">//对左半数组和右半数组进行比较，从小到大排序构建p </span><br> <span class="hljs-keyword">while</span>(i&lt;=mid)p[k++]=a[i++];<span class="hljs-comment">//把左半部分没合并的加入到p中 </span><br> <span class="hljs-keyword">while</span>(j&lt;=tail)p[k++]=a[j++];<span class="hljs-comment">//把右半部分没合并的加入到p中 </span><br> <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;=tail-head;k++)a[head+k]=p[k];<span class="hljs-comment">//把p放到a的对应位置中 </span><br> <span class="hljs-built_in">free</span>(p);<br> <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> head,<span class="hljs-type">int</span> tail)</span><br>&#123;<br> <span class="hljs-keyword">if</span>(head&lt;tail)<br> &#123;<br>  <span class="hljs-type">int</span> mid=(head+tail)/<span class="hljs-number">2</span>;<br>  MergeSort(a,head,mid);<span class="hljs-comment">//对左半部分进行排序 </span><br>  MergeSort(a,mid+<span class="hljs-number">1</span>,tail);<span class="hljs-comment">//对右半部分进行排序 </span><br>  MergeArray(a,head,mid,tail);<span class="hljs-comment">//对左右两边的数组进行合并 </span><br> &#125;<br>&#125;<br><br><br><span class="hljs-comment">//快排 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> k[ ],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span><br>&#123;     <br>    <span class="hljs-type">int</span> i, last;<br>    <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>       last=left; <br>        <span class="hljs-keyword">for</span>(i=left+<span class="hljs-number">1</span>;i&lt;=right;i++)&#123;<br>         count++;<br>            <span class="hljs-keyword">if</span>(k[i]&lt;k[left]&amp;&amp;(++last)&lt;i)<br>         swap(&amp;k[last],&amp;k[i]);<br> <span class="hljs-comment">//不断把k[i]中小于k[left]的元素往左移动，使得last正好指在小于left元素的最右边，last右侧的元素均大于left </span><br>  &#125;<br>        swap(&amp;k[left],&amp;k[last]);<span class="hljs-comment">//交换last和left处的元素 </span><br>        quickSort(k,left,last<span class="hljs-number">-1</span>); <br>        quickSort(k,last+<span class="hljs-number">1</span>,right);   <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//统计排序趟数 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n,op;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">120</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;op);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    selectsort(a,n);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    bubblesort(a,n);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    heapsort(a,n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    MergeSort(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);  <br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    quickSort(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);       <br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>,count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主定理</title>
    <link href="/2024/09/10/%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%AE%9A%E7%90%86/"/>
    <url>/2024/09/10/%E7%AE%97%E6%B3%95/%E4%B8%BB%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><p>主定理适用于求解如下递归式算法的时间复杂度：</p><p>其中：<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/-2.png"></p><p>n 是问题规模大小；<br>a 是原问题的子问题个数；<br>n&#x2F;b 是每个子问题的大小，这里假设每个子问题有相同的规模大小；<br>f(n) 是将原问题分解成子问题和将子问题的解合并成原问题的解的时间。</p><p>对上面的式子进行分析，得到三种情况：<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/-1.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python包导入问题</title>
    <link href="/2024/09/10/python/python%E5%8C%85%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/10/python/python%E5%8C%85%E5%AF%BC%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-导入机制：绝对导入与相对导入"><a href="#Python-导入机制：绝对导入与相对导入" class="headerlink" title="Python 导入机制：绝对导入与相对导入"></a>Python 导入机制：绝对导入与相对导入</h1><p>在Python中，当项目工程较大时，我们通常会将代码划分为多个包（<code>package</code>）进行管理。在这种情况下，各个模块（<code>module</code>）之间的相互导入不可避免。如果不熟悉绝对导入和相对导入的规则，可能会遇到各种导入相关的异常错误，例如：</p><ul><li><code>ModuleNotFoundError: No module named &#39;moduleY&#39;</code></li><li><code>ValueError: attempted relative import beyond top-level package</code></li><li><code>ModuleNotFoundError: No module named &#39;__main__.moduleY&#39;; &#39;__main__&#39; is not a package</code></li></ul><h2 id="目录布局示例"><a href="#目录布局示例" class="headerlink" title="目录布局示例"></a>目录布局示例</h2><p>假设项目包的目录布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">package/<br>    __init__.py<br>    subpackage1/<br>        __init__.py<br>        moduleX.py<br>        moduleY.py<br>    subpackage2/<br>        __init__.py<br>        moduleZ.py<br>    moduleA.py<br></code></pre></td></tr></table></figure><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p>在 Python 中，一个 <code>.py</code> 文件称为模块（module），包含 <code>__init__.py</code> 文件的目录称为包（package）。</p><p>当一个模块被执行时，Python 会根据 <code>sys.path</code> 给出的路径去查找在模块中引入的包或其他模块。如果找不到，则会报错。</p><h2 id="2-绝对导入"><a href="#2-绝对导入" class="headerlink" title="2. 绝对导入"></a>2. 绝对导入</h2><p>绝对导入是默认的导入方式，它更常见，并且它可以实现相对导入的所有功能。</p><h3 id="2-1-用法"><a href="#2-1-用法" class="headerlink" title="2.1 用法"></a>2.1 用法</h3><p>绝对导入可以使用 <code>import &lt;module&gt;</code> 或 <code>from &lt;module&gt; import &lt;object&gt;</code> 这两种语法。比如在 <code>moduleA</code> 模块中，以下绝对导入语句是有效的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleA.py</span><br><span class="hljs-keyword">import</span> package.subpackage1.moduleX <span class="hljs-keyword">as</span> moduleX<br><span class="hljs-keyword">from</span> package.subpackage1 <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> package.subpackage2 <span class="hljs-keyword">import</span> moduleZ<br></code></pre></td></tr></table></figure><p>需要注意的是，在当前模块中引入同级别的模块或包下的模块时，最好写完整的导入路径。例如，在 <code>moduleX</code> 中引入同一级别的 <code>moduleY</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleX.py</span><br><span class="hljs-keyword">import</span> moduleY  <span class="hljs-comment"># 错误的导入方式</span><br></code></pre></td></tr></table></figure><p>而在 <code>moduleA.py</code> 中执行以下代码时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleA.py</span><br><span class="hljs-keyword">import</span> package.subpackage1.moduleX<br></code></pre></td></tr></table></figure><p>执行 <code>python moduleA.py</code> 会提示 <code>ModuleNotFoundError: No module named &#39;moduleY&#39;</code>。</p><p>这是因为，执行 <code>moduleA</code> 的路径是 <code>D:/top/package</code>（假设 <code>D:/top</code> 是示例程序的目录），导入语句 <code>import moduleY</code> 会被解析为 <code>D:/top/package/moduleY.py</code>，但这个路径不存在。</p><p>解决方法是将 <code>moduleX</code> 中的 <code>import moduleY</code> 改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正确的导入方式</span><br><span class="hljs-keyword">import</span> package.subpackage1.moduleY<br></code></pre></td></tr></table></figure><h3 id="2-2-不足"><a href="#2-2-不足" class="headerlink" title="2.2 不足"></a>2.2 不足</h3><ul><li>导入同一个包下的模块需要写完整的导入路径，如果层级很深，路径会显得很长。</li><li>如果要改变层级较高的包名（如顶级包），所有导入路径都需要更改。</li></ul><h2 id="3-相对导入"><a href="#3-相对导入" class="headerlink" title="3. 相对导入"></a>3. 相对导入</h2><p>相对导入解决了绝对导入的一些问题：</p><ul><li>同一个包下的模块可以更方便地相互引用，使用 <code>from . import xxx</code> 的语句即可。</li><li>改变顶层包名时，包下模块的相对导入语句基本不用改动。</li></ul><h3 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1 用法"></a>3.1 用法</h3><p>相对导入只能使用 <code>from &lt;module&gt; import &lt;object&gt;</code> 这种语法，并且使用 <code>.</code> 作为前导点。</p><p>例如，在 <code>subpackage1/moduleX.py</code> 或 <code>subpackage1/__init__.py</code> 模块中，可以使用相对导入的方式导入其他模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleX.py</span><br><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> spam<br><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> spam <span class="hljs-keyword">as</span> ham<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> ..subpackage1 <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> ..subpackage2.moduleZ <span class="hljs-keyword">import</span> eggs<br><span class="hljs-keyword">from</span> ..moduleA <span class="hljs-keyword">import</span> foo<br></code></pre></td></tr></table></figure><h3 id="3-2-实现机制"><a href="#3-2-实现机制" class="headerlink" title="3.2 实现机制"></a>3.2 实现机制</h3><p>在 PEP 328 中，介绍了使用相对导入时查找导入模块的机制：</p><blockquote><p>Relative imports use a module’s <code>__name__</code> attribute to determine that module’s position in the package hierarchy. If the module’s name does not contain any package information (e.g., it is set to <code>&#39;__main__&#39;</code>), then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.</p></blockquote><p>简单来说，相对导入是通过模块的 <code>__name__</code> 属性来确定模块在包层次结构中的位置。如果 <code>__name__</code> 属性不包含任何包的信息，则把当前模块视为顶层模块。</p><p>例如，在 <code>moduleA.py</code> 和 <code>moduleZ.py</code> 中分别加入输出 <code>__name__</code> 和 <code>__package__</code> 的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleA.py</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__file__=&#123;0:&lt;35&#125; | __name__=&#123;1:&lt;20&#125; | __package__=&#123;2:&lt;20&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(__file__, __name__, <span class="hljs-built_in">str</span>(__package__)))<br><br><span class="hljs-keyword">from</span> package.subpackage2 <span class="hljs-keyword">import</span> moduleZ<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleZ.py</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__file__=&#123;0:&lt;35&#125; | __name__=&#123;1:&lt;20&#125; | __package__=&#123;2:&lt;20&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(__file__, __name__, <span class="hljs-built_in">str</span>(__package__)))<br></code></pre></td></tr></table></figure><p>执行 <code>python moduleA.py</code> 输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__file__=D:/top/package/moduleA.py           | __name__=__main__             | __package__=None                <br>__file__=D:\top\package\subpackage2\moduleZ.py | __name__=subpackage2.moduleZ  | __package__=subpackage2         <br></code></pre></td></tr></table></figure><p>我们发现 <code>moduleA.py</code> 的 <code>__name__</code> 是 <code>&#39;__main__&#39;</code>，即 <code>moduleA.py</code> 是顶层模块。而 <code>moduleZ.py</code> 的 <code>__name__</code> 是 <code>subpackage2.moduleZ</code>，因此模块 <code>moduleZ.py</code> 的顶级包是 <code>subpackage2</code>，而不是 <code>package</code>。</p><h3 id="3-3-限制条件"><a href="#3-3-限制条件" class="headerlink" title="3.3 限制条件"></a>3.3 限制条件</h3><ul><li>相对导入只适用于顶级包内的模块。</li><li>使用了相对导入的模块文件不能作为顶层执行文件。</li></ul><p>例如，<code>moduleY</code> 中引入 <code>subpackage2</code> 下的 <code>moduleZ</code> 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleY.py</span><br><span class="hljs-keyword">from</span> ..subpackage2 <span class="hljs-keyword">import</span> moduleZ<br></code></pre></td></tr></table></figure><p>执行 <code>moduleA.py</code> 时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleA.py</span><br><span class="hljs-keyword">import</span> package.subpackage1.moduleY<br></code></pre></td></tr></table></figure><p>执行 <code>python moduleA.py</code> 会引发 <code>ValueError: attempted relative import beyond top-level package</code> 异常。</p><p>这是因为模块 <code>moduleY</code> 所在的顶级包是 <code>subpackage1</code>，而 <code>subpackage1</code> 下不存在子包 <code>subpackage2</code>。</p><h3 id="相对导入的限制：顶层执行文件"><a href="#相对导入的限制：顶层执行文件" class="headerlink" title="相对导入的限制：顶层执行文件"></a>相对导入的限制：顶层执行文件</h3><p>对于如下 <code>moduleX.py</code> 的代码，执行 <code>python moduleX.py</code> 将会引发 <code>ModuleNotFoundError: No module named &#39;__main__.moduleY&#39;; &#39;__main__&#39; is not a package</code> 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moduleX.py</span><br><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><hr><p>通过了解绝对导入和相对导入的机制及其实现方式，可以更好地管理项目中的模块和包导入，避免常见错误和陷阱。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab0</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="0-1"><a href="#0-1" class="headerlink" title="0.1"></a>0.1</h3><p>README.txt位置:<br>cat Untracked.txt:位于Untracked区<br>cat Stage.txt：Staged区。<br>cat Modified.txt:modifed区。</p><h3 id="0-2"><a href="#0-2" class="headerlink" title="0.2"></a>0.2</h3><p>add the file 、stage the file 和<br>commit 分别对应的是 Git 里的 <code>git add,git add,git commit</code>命令</p><h3 id="0-3"><a href="#0-3" class="headerlink" title="0.3"></a>0.3</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.git</span> checkout -- print<span class="hljs-selector-class">.c</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.git</span> reset HEAD print<span class="hljs-selector-class">.c</span><br>git checkout -- print<span class="hljs-selector-class">.c</span><br><span class="hljs-number">3</span><span class="hljs-selector-class">.git</span> rm <span class="hljs-attr">--cached</span> hello.txt<br></code></pre></td></tr></table></figure><h3 id="0-4"><a href="#0-4" class="headerlink" title="0.4"></a>0.4</h3><p>用<code>git reset --hard</code> 进行版本回溯，功能很强大，但是一旦使用，就没有后悔药。</p><h3 id="0-5"><a href="#0-5" class="headerlink" title="0.5"></a>0.5</h3><p>执行结果：<br>1.在shell命令行中输出：<code>first</code><br>2.output.txt文件中为：<code>second</code><br>3.output.txt文件中为：<code>third</code><br>4.output.txt文件中为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">third<br>forth<br></code></pre></td></tr></table></figure><h3 id="0-6"><a href="#0-6" class="headerlink" title="0.6"></a>0.6</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">result中为：<br>Shell Start<span class="hljs-built_in">..</span>.<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">a</span>=1<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">b</span>=2<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">c</span>=a+b<br>c = 3<br>save c <span class="hljs-keyword">to</span> ./file1<br>save b <span class="hljs-keyword">to</span> ./file2<br>save a <span class="hljs-keyword">to</span> ./file3<br>save file1 file2 file3 <span class="hljs-keyword">to</span> file4<br>save file4 <span class="hljs-keyword">to</span> ./result<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p>test的第1行打印了Shell Start… test的第2行打印了set a&#x3D;1<br>test的第3行给变量a赋值为1 test的第4行打印了set b&#x3D;2<br>test的第5行给变量b赋值为2 test的第6行打印了set c&#x3D;a+b<br>test的第7行进行了c&#x3D;a+b的运算 test的第8行打印了c&#x3D;3<br>test的第9行打印了save c to .&#x2F;file1<br>test的第10行把c的值重定向到了file1中<br>test的第11行打印了save b to .&#x2F;file2<br>test的第12行把b的值重定向到了file2中<br>test的第13行打印了save a to .&#x2F;file3<br>test的第14行把a的值重定向到了file3中<br>test的第15行打印了save file1 file2 file3 to file4<br>test的17，18，19行把file1，file2，file3的内容全部重定向到了file4中<br>test的第20行打印了save file4 to .&#x2F;result<br>test的第21行把file4的内容重定向到了result中</p><h2 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2.难点分析"></a>2.难点分析</h2><ol><li>linux的shell界面不是直观的图形界面，而是用命令行进行所有的任务，一开始难以适应。</li><li>linux中有基本的命令，有许多的脚本命令，还有一些强大的工具命令，初学的命令较多，而且命令的不同参数有不同作用，容易搞混淆，这让不太熟练的初学者感到吃力。</li><li>对于Makefile的理解要到位，特别是不同target之间的依赖关系。</li><li>要学会熟练运用sed和awk等脚本语言的基础命令。</li></ol><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/lab0-1.PNG"></p><h2 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3.实验体会"></a>3.实验体会</h2><p>lab0我们主要对linux系统的命令行操作进行了简单的学习和熟悉。学习了GCC，Makefile，Git等等强大工具的基本使用。我能够明显体会到linux系统与windows系统的不同，Linux系统拥有强大的命令行工具和脚本语言，可以提高工作效率和灵活性。但强大的功能需要我们付出很高的学习成本，许多的命令需要多用多练，在脑中形成长期记忆，才能熟练掌握。<br>本次实验还带我们回忆了c语言和mips的内容，需要我们再一次回顾计组的内容，在学习OS的过程中起到承上启下的作用，也便于我们更好地理解OS的底层原理。</p><table><thead><tr><th align="left">git branch -l                   # 查看所有分支</th></tr></thead><tbody><tr><td align="left">git checkout <branch_name>      # 切换到指定分支</td></tr><tr><td align="left">git checkout -b <branch_name>   # 根据当前分支，新建一个分支并切换到该分支上</td></tr><tr><td align="left">git merge [<branch1>] <branch2> # 将branch2合并到branch1，省略branch1参数时表示合并到当前分支</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab1</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul><li>ld是链接器工具，用于将编译后的目标文件链接成可执行文件或共享库。</li><li>readelf是一个用于查看ELF格式文件（包括可执行文件、共享库等）的工具。它可以显示ELF文件的各个段、符号表、重定位表等信息，帮助用户了解可执行文件的结构和内容。</li><li>mips-linux-gnu-前缀通常用于指明目标架构为MIPS架构的Linux系统。</li><li>objdump -DS hello命令用于对名为hello的可执行文件进行反汇编，并显示汇编代码和符号表信息。下面是每个参数的含义：</li></ul><ol><li>objdump：用于显示目标文件信息的工具。</li><li>-D：指定显示反汇编代码。该选项会将目标文件中的机器指令反汇编成汇编代码并显示。</li><li>-S：指定同时显示源代码和反汇编代码。该选项会尝试将反汇编代码与源代码对应起来显示。<br>hello：要反汇编的目标文件的文件名。在这里是名为hello的可执行文件。<br>通过执行objdump -DS hello命令，可以查看hello可执行文件的反汇编代码和符号表信息，帮助理解程序的实现细节和结构。</li></ol><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/lab1-1.PNG"><br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/lab1-2.PNG"><br>通过 readelf -h命令，可以看到我们编写的readelf文件是ELF64，而hello文件是ELF32，我们编写的readelf文件只能够解析32位类型的文件，所以不能解析它本身。</p><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>因为上电是OS启动的第一个阶段，首先启动bootloader程序，在stage1阶段初始化硬件设备。此时对于MIPS处理器来说，MIPS体系结构上电时，启动入口的地址为0xBFC00000（或为某一个确定的地址）。<br>在stage2阶段，我们才将内核镜像加载到内存指定的位置，即内存布局图放置，我们可以从mips_init()跳转到正确的内核。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h3><p>难点在于理解elf.h文件中的结构体，以及理解ELF文件的结构。</p><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/lab1-4.PNG"></p><h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2"></a>1.2</h3><p>根据内存示意图进行放置即可</p><h3 id="1-3-1"><a href="#1-3-1" class="headerlink" title="1.3"></a>1.3</h3><ul><li>于看懂printk代码所要实现的功能，理解参数和变量的含义。</li><li>注意是按照%[flags][width][.precision][length]specifier这样的顺序进行的<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/lab1-3.PNG"></li></ul><h2 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h2><p>从lab1的实验，我们初步学到了os的启动过程。我们学会了如何把kernel放到内存正确的位置。还学习了ELF文件的格式。<br>在完成readelf练习的过程中，我感觉初次阅读ELF文件的源码有一定困难。</p><p>同时，对于指导书中的Makefile文件，我觉得阅读起来比较吃力，许多宏定义不熟悉，许多命令和参数也不认识。</p><p>在完成printk函数时，我卡了很久，在阅读各个文件源码后，才理解该函数的作用是实现printf的功能。同时对于提示中的flush the string ，即第二处需要补充的代码，我不能理解提示的要求，不知道out函数具体实现了什么功能。还有在完成print_num的时候，对于neg_flag的判断也卡了一下。</p><p>我认为需要稳固c语言和mips的基础，增强代码的阅读能力，才能更好的理解os实验的源码。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab2</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>在编写的 C 程序中，指针变量中存储的地址被视为<strong>虚拟地址</strong><br>MIPS汇编程序中<code>lw</code>和<code>sw</code>指令使用的地址被视为<strong>虚拟地址</strong></p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><ol><li></li></ol><p>使用宏来实现链表具有以下好处：<br>用宏实现链表，可以避免重复劳动，因为宏没有规定返回值的类型。<br>2.<br>单向链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n)；<br>循环链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n)；<br>双向链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(1)；</p><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p>正确的结构选C</p><h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><ol><li></li></ol><ul><li>ASID可以唯一标识每个进程，可以为该进程提供地址空间保护，当TLB尝试解析虚拟页码时，它确保当前正在运行的进程的ASID与与虚拟页面关联的ASID匹配。</li><li>同时也使得不同的虚拟地址空间可以映射到同一块物理地址，有利于提高CPU的利用率。</li></ul><ol start="2"><li></li></ol><p>4kc中ASID的位数为8位，说明可容纳不同地址的空间的最大数量位为$2^8$</p><h3 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h3><p><code>tlb_invalidate</code> 调用了<code>tlb_out</code><br><code>tlb_invalidate</code> 函数实现删除特定虚拟地址在TLB<br>中的旧表项</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mips">LEAF(tlb_out)<br><span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI //将 <span class="hljs-built_in">EntryHi</span>中key加载到寄存器<span class="hljs-built_in">t0</span>中<br> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">a0</span>, CP0_ENTRYHI//将旧表项Key写入<span class="hljs-built_in">EntryHi</span><br> <span class="hljs-keyword">nop//空指令</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">tlbp </span>//根据<span class="hljs-built_in">EntryHi</span>中的Key查找对应的旧表项，将表项的索引存入Index<br> <span class="hljs-keyword">nop//空指令</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t1</span>, CP0_INDEX //将旧表项的索引存入<span class="hljs-built_in">t1</span>寄存器<br><span class="hljs-meta">.set</span> reorder<br> <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">t1</span>, NO_SUCH_ENTRY //如果<span class="hljs-built_in">t1</span>的值为负，则跳转到标签NO_SUCH_ENTRY处<br><span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYHI //否则，向<span class="hljs-built_in">EntryHi</span>寄存器写入<span class="hljs-number">0</span><br> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO0//向<span class="hljs-built_in">EntryLo0</span>寄存器写入<span class="hljs-number">0</span><br> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO1//向<span class="hljs-built_in">EntryLo1</span>寄存器写入<span class="hljs-number">0</span><br> <span class="hljs-keyword">nop </span>  //空指令<br> <span class="hljs-keyword">tlbwi </span>//将<span class="hljs-built_in">EntryHi</span>和<span class="hljs-built_in">EntryLo0</span>、<span class="hljs-built_in">EntryLo1</span>中的值写入索引指定的表项<br><span class="hljs-meta">.set</span> reorder<br></code></pre></td></tr></table></figure><h3 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h3><ul><li><p>MIPS主要采用的是页式管理系统，X86主要采用的是段页式。</p></li><li><p>MIPS 会触发TLB Refill 异常，内核的 tlb_refill_handler 会以 pgd_current 为当前进程的 PGD 基址，索引获得转换失败的虚址对应的 PTE，并将其填入 TLB，完了CPU 把刚刚转换失败的虚地址再走一下 TLB 就OK了。而 X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。</p></li><li><p>另外转换失败的虚址，MIPS 使用 BadVAddr 寄存器存放，X86 使用 CR2 存放。</p></li></ul><h3 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h3><p>三级页表页目录的基地址为：<br> $PT_{base}|PT_{base}&gt;&gt;9|PT_{base}&gt;&gt;18$</p><p>映射到页目录自身的页目录项:<br> $PT_{base}|PT_{base}&gt;&gt;9|PT_{base}&gt;&gt;18|PT_{base}&gt;&gt;27$</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><ol><li>对于双向链表的理解：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name, type)                                                                      \</span><br><span class="hljs-meta"> struct name &#123;                                                                              \</span><br><span class="hljs-meta">  struct type *lh_first; <span class="hljs-comment">/* first element */</span>                                         \</span><br><span class="hljs-meta"> &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                                           \</span><br><span class="hljs-meta"> struct &#123;                                                                                   \</span><br><span class="hljs-meta">  struct type *le_next;  <span class="hljs-comment">/* next element */</span>                                          \</span><br><span class="hljs-meta">  struct type **le_prev; <span class="hljs-comment">/* address of previous next element */</span>                      \</span><br><span class="hljs-meta"> &#125;</span><br><br>LIST_HEAD(Page_list, Page);<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br> Page_LIST_entry_t pp_link; <span class="hljs-comment">/* free list link */</span><br><br> <span class="hljs-comment">// Ref is the count of pointers (usually in page table entries)</span><br> <span class="hljs-comment">// to this page.  This only holds for pages allocated using</span><br> <span class="hljs-comment">// page_alloc.  Pages allocated at boot time using pmap.c&#x27;s &quot;alloc&quot;</span><br> <span class="hljs-comment">// do not have valid reference count fields.</span><br><br> u_short pp_ref;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>根据上述定义代码可以很好的理解页中双向链表的结构。</p><ol start="2"><li>难点在于二级页表的查询机制和相关函数的理解：<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2/lab2-2.PNG"><br>重点在于对pgdir_walk函数的理解，该函数构建了虚拟地址对应的一级页目录项和二级页表的对应关系。其中对于指针所指向的地址理解也十分重要<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2/lab2-1.PNG"><br>参考上图<br>pgdir代表的是一级页表基地址<br>pgdir_entryp则是代表查询的页目录项地址<br>*pgdir_entryp存的则是对应二级页表的物理页号和权限位<br>*ppte存的则是该页对应的二级页表项的地址。</li></ol><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab2实验的整体难度较高，涉及了mips的内存管理。尤其是其中的二级页表和快表机制在实际写代码时比较绕，自映射也很难理解，花费了大量时间和精力理解。同时需要完成的内容较多，主要涉及了c语言的指针，容易搞混。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab3</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p><code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code>中，</p><p><code>UVPT</code>：用户页表的起始处的内核虚拟地址</p><p><code>PDX(UVPT)</code>：UVPT所处的页目录号（即 UVPT 处于第 PDX(UVPT) 个页目录项所映射的4MB空间；联系 UVPT 的含义，因此页目录也被第PDX(UVPT)映射）</p><p><code>e-&gt;env_pgdir</code>：进程 e 的页目录的内核虚拟地址</p><p><code>PADDR(e-&gt;env_pgdir)</code>：进程 e 的页目录的物理地址</p><p><code>PADDR(e-&gt;env_pgdir) | PTE_V</code>：页目录的物理基地址加上权限位</p><p>页目录基地址&#x3D;<code>UVPT+UVPT&gt;&gt;10</code></p><p>页目录的Page number&#x3D;<code>(UVPT+UVPT&gt;&gt;10)&gt;&gt;12</code>;</p><p>页目录中<strong>映射到页目录基地址</strong>的<strong>项A的地址</strong>&#x3D;<code>UVPT+Page number*4=UVPT+UVPT&gt;&gt;10+UVPT&gt;&gt;20</code></p><p>页表项A所在的页目录号&#x3D;（项的地址-页目录基地址）&#x2F;4&#x3D;<code>UVPT&gt;&gt;20&gt;&gt;2</code>&#x3D;<code>PDX(UVPT)</code>  </p><p><code>e-&gt;env_pgdir[PDX(UVPT)]</code>:代表项A中存储的物理页号和权限位，即页目录的物理基地址加权限位</p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p><code>data</code>是传入的进程控制块指针，在<code>load_icode_mapper</code>中有<code>struct Env *env = (struct Env *)data;</code><br>在建立虚拟地址到物理地址的页表映射的时候提供<code>env_pgdir</code>和<code>env_asid</code>；<br>如果没有<code>data</code>，<code>load_icode_mapper</code>就不能知道当前进程空间的页目录基地址和asid。</p><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/lab3-1.PNG"></p><ol><li>若<code>va</code>不按照<code>PAGE_SIZE</code>对齐，算出<code>offset</code>，将<code>offset</code>中的<code>bin</code>数据写入对应的内存地址并建立页表映射关系。</li><li>将段内的每一页数据写入对应的内存地址并建立页表的映射关系。</li><li>若发现段在内存的大小<code>sg_size</code>大于在ELF文件中的大小<code>bin_size</code>，则需要把多余的空间用0填充满</li></ol><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>这里的<code>env_tf.cp0_epc</code>字段指示了进程恢复运行时PC应恢复到的位置，对于CPU来说，cpu直接接触的地址是虚拟地址，所以<code>env_tf.cp0_epc</code>中存的是虚拟地址</p><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p><code>handle_int</code>在<code>genex.S</code>中用mips宏定义实现，而<code>handle_mod</code>和<code>handle_tlb</code>中在<code>genex.S</code>仅仅有宏定义，实际在函数<code>do_tlb_mod</code>和<code>do_tlb_refill</code>中实现。</p><h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>在这段代码中，时钟中断的开启和关闭是通过对 <code>CP0_CAUSE</code> 寄存器和 <code>CP0_STATUS</code> 寄存器进行操作来实现的。</p><p><code>时钟中断的开启</code>：<br>MOS中，时钟中断的初始化发生在调度执行每一个进程之前。从代码角度，就是在<code>env_pop_tf</code>中调用了宏<code>RESET_KCLOCK</code>，随后又在宏 <code>RESTORE_ALL</code> 中恢复了 Status 寄存器，开启了中断。</p><p><code>时钟中断的关闭</code>：<br>在<code>.text.exc_gen_entry</code>处将UM、EXL和IE位清零，确保处理器处于内核模式，并且禁用中断。</p><h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><p>进程装在两个队列中，一次运行一个进程。定时器周期性产生中断，使得当前进程被迫停止，进入<code>.text.exc_gen_entry</code>，逐步执行到<code>schedule</code>调度函数,若该进程时间片还未用完，则可用时间片数量－1，继续执行该进程，否则会切换到下一个进程，保存上下文，并将原来的进程送到调度队列的末尾，若进程不处于RUNNABLE状态，则会进行其他处理。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><ol><li>进程的创建</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Control block of an environment (process).</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span> <span class="hljs-comment">// saved context (registers) before switching</span><br>LIST_ENTRY(Env) env_link; <span class="hljs-comment">// intrusive entry in &#x27;env_free_list&#x27;</span><br>u_int env_id; <span class="hljs-comment">// unique environment identifier</span><br>u_int env_asid; <span class="hljs-comment">// ASID of this env</span><br>u_int env_parent_id; <span class="hljs-comment">// env_id of this env&#x27;s parent</span><br>u_int env_status; <span class="hljs-comment">// status of this env</span><br>Pde *env_pgdir; <span class="hljs-comment">// page directory</span><br>TAILQ_ENTRY(Env) env_sched_link; <span class="hljs-comment">// intrusive entry in &#x27;env_sched_list&#x27;</span><br>u_int env_pri; <span class="hljs-comment">// schedule priority</span><br><br><span class="hljs-comment">// Lab 4 IPC</span><br>u_int env_ipc_value;   <span class="hljs-comment">// the value sent to us</span><br>u_int env_ipc_from;    <span class="hljs-comment">// envid of the sender</span><br>u_int env_ipc_recving; <span class="hljs-comment">// whether this env is blocked receiving</span><br>u_int env_ipc_dstva;   <span class="hljs-comment">// va at which the received page should be mapped</span><br>u_int env_ipc_perm;    <span class="hljs-comment">// perm in which the received page should be mapped</span><br><br><span class="hljs-comment">// Lab 4 fault handling</span><br>u_int env_user_tlb_mod_entry; <span class="hljs-comment">// userspace TLB Mod handler</span><br><br><span class="hljs-comment">// Lab 6 scheduler counts</span><br>u_int env_runs; <span class="hljs-comment">// number of times we&#x27;ve been env_run&#x27;ed</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在本次实验中，PCB控制块实则以Env的结构体体现出来，实验中前几个函数都涉及到这个结构体的内容，需要认真理解。</p><ol start="2"><li>加载二进制镜像到内存中<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/lab3-2.PNG"></li></ol><ul><li><p>其中<code>load_icode</code>函数的理解较难，调用了<code>elf_load_seg</code>函数，需要理解ELF文件的段是如何加载到内存中的。这里的情况较为复杂，首先需要考虑虚拟地址对齐的问题，其次还需要考虑段在文件中的大小和在内存中的大小问题，如果前者小于后者，需要进行补0操作。</p></li><li><p>同时，这里也涉及lab2内存管理的一些内容，我们需要调用<code>page_alloc</code>,<code>page_insert</code>等函数，用页的方式加载段到内存中，同时建立起页表中虚拟地址和物理地址的映射关系。</p></li></ul><ol><li>时钟中断机制的理解</li></ol><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/lab3-3.PNG"><br>这里涉及的函数较多，还涉及很多mips的宏定义和函数定义，理解起来十分复杂。需要根据时钟中断的步骤来理清每个函数的调用过程。</p><ul><li><code>RESET_KCLOCK</code> 宏将 Count 寄存器清零并将 Compare 寄存器配置为我们所期望的计时器周期数，这就对Timer完成了配置。在设定个时钟周期后，时钟中断将被触发。</li><li>MOS中，时钟中断的初始化发生在调度执行每一个进程之前。从代码角度，就是在<code>env_pop_tf</code>中调用了宏<code>RESET_KCLOCK</code>，随后又在宏 <code>RESTORE_ALL</code> 中恢复了 Status 寄存器，开启了中断。</li><li>一旦时钟中断产生，就会触发4KC硬件的异常中断处理流程。系统将 PC指向 <code>0x80000180</code>，<br>跳转到<code>.text.exc_gen_entry</code> 代码段执行。对于时钟引起的中断，通过<code>.text.exc_gen_entry</code>代码段的分发，最终会调用<code>handle_int</code> 函数进行处理。</li><li><code>handle_int</code> 函数根据 Cause 寄存器的值判断是否是 Timer 对应的 7 号中断位引发的时钟中断，如果是，则执行中断服务函数 <code>timer_irq</code>，跳转到 <code>schedule</code> 中执行。</li><li><code>schedule</code>根据不同的中断类型调用不同的处理函数，再调用<code>env_run</code>运行进程。</li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab3的课下实验相较于lab2较为简单，但是进程的机制理解起来比较复杂，涉及到内存管理，进程切换，进程创建等方方面面。其中特别是对进程调度的核心算法和流程的理解十分重要。</p><p><strong>对于进程调度的总结</strong>：<br><code>e-&gt;env_pri</code> ： 进程每次运行的时间片数量；</p><p><code>curenv</code>全局变量：当前正在运行的进程（在第一 个进程被调度前为 NULL）；</p><p><code>count</code>静态变量：当前正在运行进程的剩余时间片数量 &#x3D; 当前进程剩余的执行次数；</p><p><code>env_sched_list</code>调度队列：存在且只存在所有就绪（状态为 <code>ENV_RUNNABLE</code>）的进程，其中也需要包括正在运行的进程；</p><p>当满足下列条件中的任意一个时，需要进程切换：</p><ul><li>尚未调度过任何进程（<code>curenv == NULL</code>）</li><li>当前进程已经用完了时间片（<code>count == 0</code>）</li><li>当前进程不再就绪，如：被阻塞或退出（<code>e-&gt;env_status != ENV_RUNNABLE</code>）</li><li><code>yield</code> 参数指定必须发生切换（<code>yield != 0</code>）</li><li>无需进程切换时，将剩余时间片数量 <code>count</code> 减去 1，然后调用 <code>env_run</code> 函数；</li></ul><p>需要进程切换时，判断当前进程是否仍然就绪，如果是则将其移动到调度链表的尾部。之后，我们选中调度链表首部的进程来调度运行，将剩余时间片数量设置为其优先级。</p><p>调度函数 <code>schedule</code> 以及其中逐级调用的 <code>env_run、env_pop_tf</code> 和 <code>ret_from_exception</code> 函数都是不返回（no return）的函数，被调用后会从内核跳转到被调度进程的用户程序中执行。在 MIPS 中通常使用 j 指令而非 jal 调用不返回的函数，因为它们不会再返回到其调用者。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab4</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab4/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><p>4.1</p><ol><li><code>内核在保存现场的时候是如何避免破坏通用寄存器的？</code></li></ol><p>保存现场过程中，先通过<code>k0</code>寄存器暂存<code>sp</code>栈指针的值，之后将其余通用寄存器的值直接存到<code>cp</code>的协寄存器中。</p><ol start="2"><li><code>系统陷入内核调用后可以直接从当时的`$a0-$a3`参数寄存器中得到用户调用`msyscall`留下的信息吗？</code></li></ol><p>可以。从用户函数<code>syscall_*()</code>到内核函数<code>sys_*()</code>时，<code>$a1-$a3</code>未改变,<code>$a0</code>在<code>handle_sys()</code>的时候被修改为内核函数的地址，但在内核函数<code>sys_*()</code>仅为占位符，不会被用到。</p><ol start="3"><li><code>我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？</code></li></ol><p>用户调用时的参数：用户进程的寄存器现场(保存在了内核栈的<code>TF_5-TF_7</code>)的<code>$a1-$a3</code>;用户栈的参数<code>$a4$a5</code><br>把上面两部分参数分别拷贝至<code>arg1-arg5</code>,在sys函数中作为参数传入。</p><ol start="4"><li><code>内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是什么？</code></li></ol><p>对<code>Trapframe</code>结构体中的<code>cp0_epc</code>的值增加了4，并将<code>sys</code>开头函数的返回值存入<code>v0</code>寄存器，保证了系统调用后用户态进程可以获得正确的返回值，并且从触发系统调用的下一条指令继续执行。</p><p>4.2<br>判断<code>e-&gt;env_id != envid</code>的情况是为了确保所请求的<code>envid</code>与找到的环境的实际ID匹配。如果没有这个检查，可能将错误的<code>env</code>分配给<code>*penv</code></p><p>4.3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!envid)&#123;<br>  *penv=curenv;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<span class="hljs-keyword">else</span>&#123;<br>  e=&amp;envs[ENVX(envid)];<br> &#125;<br> <span class="hljs-keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;<br>  <span class="hljs-keyword">return</span> -E_BAD_ENV;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>从<code>envid2env</code>函数中可以看出，<code>curenv</code>分配的<code>envid</code>为0，因此，0用来作为目前运行进程的特判符。所以在给<code>env</code>分配<code>envid</code>时，使用的<code>mkenvid</code>返回值不能为0。</p><p>4.4</p><p>C</p><p>4.5</p><p><code>USTACKTOP</code>以下的应该映射。<br>但是<code>UTEMP</code>之下的<code>invalid memory</code> 是为处理页写入异常时做缓冲区用的，不需要共享。<br><code>UTOP</code>以上页面的内存与页表是所有进程共享的，且用户进程无权限访问，不需要做父子进程间的<code>duppage</code>。</p><p>4.6</p><ul><li>vpt和vpd分别代表页表项数组和页目录项数组，可以使用<code>vpt[index]</code>和<code>vpd[index]</code>的方式去访问页表项和页目录项。</li><li>由于用户进程下的系统调用的虚拟内存管理的函数传入的pgdir均为env结构体的kuseg的进程页目录，并且env_setup_vm()时把页目录进行自映射e-&gt;env_pgdir[PDX(UVPT)] &#x3D; e-&gt;env_cr3，所以实现了用户进程的虚拟内存管理，可以通过两级页表机制访问。<br>-参考vpt和vpd的定义代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vpt ((const volatile Pte *)UVPT) <span class="hljs-comment">//它将 UVPT（用户虚拟页表基址）转换为 Pte 类型的指针。</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))<span class="hljs-comment">//虚拟页目录基址转换为页目录项</span></span><br></code></pre></td></tr></table></figure><p>其中<code>vpd</code>的定义体现了页目录自映射。</p><p>-可以，因为在pmap.c中实现的虚拟内存机制，给页表项和页目录项的perm均为可写。</p><p>4.7</p><ul><li>注意以下代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (tf-&gt;regs[<span class="hljs-number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="hljs-number">29</span>] &gt;= UXSTACKTOP) &#123;<br> tf-&gt;regs[<span class="hljs-number">29</span>] = UXSTACKTOP;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，这里实现了类似“异常重入”的机制，即sp指针已经位于用户异常栈，即此时已经发生<code>tlb_mod</code>异常时，当再次发生相同的异常，重新将sp指向栈顶，会发生这种“异常重入”。</p><ul><li><code>tlb_mod</code>的异常处理比较特殊，真正的核心处理函数为<code>cow_entry()</code>，而这个函数位于用户态空间，也就是说，我们实际是在用户态进行异常处理的核心部分，所以我们需要将异常的现场<code>Trapframe</code>复制到用户空间，方便处理完异常后恢复现场。</li></ul><p>4.8</p><p>解放内核，不用内核执行大量的页面拷贝工作。同时符合MIPS4KC的微内核设计，将一些功能放到用户空间实现，提高了内核的稳定性和可移植性。</p><p>4.9</p><ul><li><p>第一次<code>syscall_set_tlb_mod_entry</code>是针对父进程设置的。子进程 <code>RUNNABLE</code> 后会从 <code>syscall_exo_fork</code> 逐级调用的 syscall 指令之后开始执行。如果在 <code>syscall_exo_fork</code> 之后再 <code>syscall_set_tlb_mod_entry</code>，那么子进程也会执行这个系统调用。</p></li><li><p>父进程运行时在函数调用等情形下会修改栈。在栈空间的页面标记为写时复制之后，父进程继续运行并修改栈，就会触发 TLB Mod 异常。所以在写时复制保护机制完成之前就需要 <code>syscall_set_tlb_mod_entry</code>。</p></li></ul><h2 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2.难点分析"></a>2.难点分析</h2><ol><li>系统调用<br>对于系统调用中几个函数调用顺序的理解。<br><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab4/lab4-1.PNG"><br>系统调用本身是为了陷入内核态，因为一些操作只能在内核态实现。<br>其中从用户态到内核态的函数传参较难理解。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_syscall</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span> &#123;<br> <span class="hljs-type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);<br> <span class="hljs-type">int</span> sysno = tf-&gt;regs[<span class="hljs-number">4</span>];<br> <span class="hljs-keyword">if</span> (sysno &lt; <span class="hljs-number">0</span> || sysno &gt;= MAX_SYSNO) &#123;<br>  tf-&gt;regs[<span class="hljs-number">2</span>] = -E_NO_SYS;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br><br> <span class="hljs-comment">/* Step 1: Add the EPC in &#x27;tf&#x27; by a word (size of an instruction). */</span><br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (1/4) */</span><br> tf-&gt;cp0_epc+=<span class="hljs-number">4</span>;<br> <span class="hljs-comment">/* Step 2: Use &#x27;sysno&#x27; to get &#x27;func&#x27; from &#x27;syscall_table&#x27;. */</span><br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (2/4) */</span><br> func=syscall_table[sysno];<br> <span class="hljs-comment">/* Step 3: First 3 args are stored in $a1, $a2, $a3. */</span><br> u_int arg1 = tf-&gt;regs[<span class="hljs-number">5</span>];<br> u_int arg2 = tf-&gt;regs[<span class="hljs-number">6</span>];<br> u_int arg3 = tf-&gt;regs[<span class="hljs-number">7</span>];<br><br> <span class="hljs-comment">/* Step 4: Last 2 args are stored in stack at [$sp + 16 bytes], [$sp + 20 bytes]. */</span><br> u_int arg4, arg5;<br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (3/4) */</span><br> arg4=*(u_int *)(tf-&gt;regs[<span class="hljs-number">29</span>]+<span class="hljs-number">16</span>);<br> arg5=*(u_int *)(tf-&gt;regs[<span class="hljs-number">29</span>]+<span class="hljs-number">20</span>);<br> <span class="hljs-comment">/* Step 5: Invoke &#x27;func&#x27; with retrieved arguments and store its return value to $v0 in &#x27;tf&#x27;.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (4/4) */</span><br> tf-&gt;regs[<span class="hljs-number">2</span>]=func(arg1,arg2,arg3,arg4,arg5);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们通过Trapframe结构体保存了用户现场的上下文，以此在内核态进行传参，同时再通过<strong>系统调用处理函数表</strong>跳转到具体的调用函数，同时又在tf-&gt;regs[2]中，即v0寄存器中保存系统调用的返回值。</p><ol><li>进程间IPC通信</li></ol><p>这里的主要难点在于集中了对lab3和lab4前半部分的的综合理解运用，涉及了进程间的切换和系统调用。</p><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab4/lab4-2.PNG"></p><p>按照上述的图示去理解ipc的通信过程，即一个进程先发出<code>ipc_recv</code>的信号之后，再调用<code>schedule(1)</code>切换到另一个进程进行<code>ipc_send</code>，从而实现两个进程间的通信。</p><ol><li>fork的实现</li></ol><p>首先要理解函数<code>duppage()</code>，这是实现父进程将地址空间中需要与子进程共享的页面映射给子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">syscall_mem_map(<span class="hljs-number">0</span>, addr, envid, addr, perm);<span class="hljs-comment">//先将子进程映射到父进程映射的物理页实现共享</span><br><span class="hljs-keyword">if</span>(r)<br>syscall_mem_map(<span class="hljs-number">0</span>,addr,<span class="hljs-number">0</span>,addr,perm);<span class="hljs-comment">//再用新的映射覆盖自己旧的映射改变权限位</span><br></code></pre></td></tr></table></figure><p>同时注意先修改子进程的权限，如果先直接映射自身，那么权限位改为PTE_COW后，无法再对子进程进行映射（会陷入写时异常，还没有实现）</p><p>我们还需要注意fork中涉及处理页写入异常，这是一种特殊的异常，异常处理的核心函数<code>cow_entry()</code>是在用户态下调用的。<br>函数中<code>memcpy((void*)UCOW,(void*)ROUNDDOWN(va,PAGE_SIZE),PAGE_SIZE);</code>复制写时错误页的信息，需要进行向下对齐，本质上是将地址的后12位清0，得到页号。</p><p>fork函数在进行映射之前，一定要查询页目录项和页表项是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; VPN(USTACKTOP); i++) &#123;<br>  <span class="hljs-keyword">if</span> ((vpd[i &gt;&gt; <span class="hljs-number">10</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;<br>   duppage(child, i);<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>fork函数是由父进程进行调用的，但是却有两个返回值，这是因为子进程的返回值：<code>e-&gt;env_tf.regs[2]=0;</code>,即保留在v0寄存器中。</p><h2 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3.实验体会"></a>3.实验体会</h2><p>涉及不同进程之间的操作以及系统调用，这部分内容综合了整个前面的lab，难度较大，需要对OS有深刻的认识。</p><p>课下需要填写的内容较多，分散在不同的文件，实则上如果从os的涉及来看，各个文件的代码是联系紧密的。</p><p>课上上机考察十分细致，需要对整个系统调用的过程和进程之间的ipc的工作过程有清晰的认识，要理解函数之间的调用关系。</p><p>要时刻注意区分<strong>内核态</strong>和<strong>用户态</strong>，这样在补充函数时不会出现一些奇奇怪怪的bug。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab5</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>5.1</p><h3 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h3><ul><li><p>当通过 kseg0 对设备进行写操作时，如果写入操作被缓存，那么实际的数据并没有直接写入设备寄存器，而是暂存在缓存中，如果发生断电等情况，缓存中的数据可能会丢失，这可能会导致数据写入失败。</p></li><li><p>设备物理内存处的数据不只由 CPU 决定，还和对应的外设的行为有关。而缓存只能记录CPU 的读写结果，无法在外设对数据进行改时及时调整。</p></li></ul><h3 id="设备操作的差异"><a href="#设备操作的差异" class="headerlink" title="设备操作的差异"></a>设备操作的差异</h3><p>对于串口设备来说，读写频繁，信号多，在相同的时间内发生错误的概论远高于IDE磁盘。<br>对于磁盘而言，磁盘一次读写的数据量较大。</p><p>5.2</p><p>根据定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_STRUCT_SIZE 256</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE PAGE_SIZE</span><br><br></code></pre></td></tr></table></figure><ul><li><p>这代表1个文件控制块大小为256B,而一个磁盘块大小为4096B,一个磁盘块最多可以存的文件控制块：$4096&#x2F;256&#x3D;16$</p></li><li><p>一个目录包含1024个指向磁盘块的指针，即最多有1024 * 16 &#x3D; 16384个文件。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BLOCK_SIZE / 4)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE (NINDIRECT * BLOCK_SIZE)</span><br></code></pre></td></tr></table></figure><ul><li>一个文件控制块有直接指针 + 间接指针共1024个 ，每个指针指向一个磁盘块，存储着该文件的一部分文件数据。文件系统支持的单个文件最大，则表示1024个指针全部有效，一共指向了1024个磁盘块存着文件数据，又一个磁盘块4KB,则单个文件最大为4KB*1024&#x3D;4MB</li></ul><p>5.3</p><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/lab5-1.PNG"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Maximum disk size we can handle (1GB) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISKMAX 0x40000000</span><br></code></pre></td></tr></table></figure><p>我们实验使用的内核支持的最大磁盘大小为1GB</p><p>5.4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/*serv.h*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_DIRTY 0x0004 <span class="hljs-comment">// 文件系统块缓存是脏的</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECT_SIZE 512  <span class="hljs-comment">/* 每个磁盘扇区的字节数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECT2BLK (BLOCK_SIZE / SECT_SIZE) <span class="hljs-comment">/* 扇区转换成块的比率 */</span></span><br><br><span class="hljs-comment">/* 磁盘块n，在内存中，映射到文件系统服务器的地址空间在DISKMAP+(n*BLOCK_SIZE)。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISKMAP 0x10000000</span><br><br><span class="hljs-comment">/* 我们能处理的最大磁盘大小（1GB） */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISKMAX 0x40000000</span><br><br><span class="hljs-comment">/*fs.h*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK (BLOCK_SIZE / sizeof(struct File)) <span class="hljs-comment">// 文件到块的转换率（一个文件描述符占据的块数）</span></span><br><br><span class="hljs-comment">// 文件描述符中直接块指针的数量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BLOCK_SIZE / 4) <span class="hljs-comment">// 间接块的数量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE (NINDIRECT * BLOCK_SIZE) <span class="hljs-comment">// 文件的最大大小</span></span><br></code></pre></td></tr></table></figure><p>5.5</p><p>fork 前后的父子进程共享文件描述符和定位指针。</p><p>验证程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;lib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR); <span class="hljs-comment">// 打开（如果需要则创建）一个测试文件</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        user_panic(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *text = <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>    write(fd, text, <span class="hljs-built_in">strlen</span>(text));  <span class="hljs-comment">// 向文件写入数据</span><br><br>    <span class="hljs-type">int</span> pid = fork();  <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        user_panic(<span class="hljs-string">&quot;fork failed&quot;</span>);<br>        close(fd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>  buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-keyword">if</span> (read(fd, buf, <span class="hljs-number">256</span>)&lt;<span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;child read : %d&quot;</span>, fd);<br>        &#125;<br>        writef(<span class="hljs-string">&quot;child read is good &amp;&amp; child_fd == %d\n&quot;</span>,fd);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fdd</span>;</span><br>        fd_lookup(fd,&amp;fdd);<br>        writef(<span class="hljs-string">&quot;child_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">if</span>(read(fdnum, buf, <span class="hljs-number">511</span>)&lt;<span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;father read: %d&quot;</span>, fd);<br>        &#125;<br>        writef(<span class="hljs-string">&quot;father read is good &amp;&amp; father_fd == %d\n&quot;</span>,r);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fdd</span>;</span><br>        fd_lookup(fd,&amp;fdd);<br>        writef(<span class="hljs-string">&quot;father_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br>    <span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// 文件名，长度由MAXNAMELEN定义</span><br>    <span class="hljs-type">uint32_t</span> f_size;         <span class="hljs-comment">// 文件的大小，以字节为单位</span><br>    <span class="hljs-type">uint32_t</span> f_type;         <span class="hljs-comment">// 文件类型，例如常规文件、目录等</span><br>    <span class="hljs-type">uint32_t</span> f_direct[NDIRECT]; <span class="hljs-comment">// 直接指针数组，用于直接指向文件数据块</span><br>    <span class="hljs-type">uint32_t</span> f_indirect;     <span class="hljs-comment">// 间接指针，指向一个间接数据块，该块包含更多数据块的指针</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span>      <span class="hljs-comment">// 指向此文件所在目录的文件结构体指针，仅在内存中有效</span><br>    <span class="hljs-type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];<br>                             <span class="hljs-comment">// 填充字段，用于确保结构体的总大小和对齐</span><br>&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed)); <span class="hljs-comment">// 确保结构体按4字节对齐且打包，无额外空间</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span><br>    u_int fd_dev_id;       <span class="hljs-comment">// 设备ID，用于标识文件所在的设备</span><br>    u_int fd_offset;       <span class="hljs-comment">// 文件在设备上的偏移量，用于数据读写位置标识</span><br>    u_int fd_omode;        <span class="hljs-comment">// 文件或设备的操作模式，例如只读、只写或读写</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span>        <span class="hljs-comment">// 包含设备信息和操作模式的文件描述符结构</span><br>    u_int f_fileid;        <span class="hljs-comment">// 文件ID，用于唯一标识文件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span>    <span class="hljs-comment">// 文件的元数据结构体，包含文件名、大小、类型等信息</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>5.7</p><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/lab5-2.PNG"></p><ul><li><code>ENV_CREATE(user_env)</code> 和 <code>ENV_CREATE(fs_serv)</code> 由初始化进程 <code>init()</code> 执行以创建用户和文件系统服务环境。<code>init()</code> 启动时创建这些环境，其中 <code>fs</code> 和 <code>user</code> 环境执行它们的初始化工作。</li><li><code>fs</code> 环境初始化后，<code>serv_init()</code> 和 <code>fs_init()</code> 函数运行，进入 <code>serv()</code> 循环，监听 <code>ipc_receive()</code> 的请求并将环境标记为 <code>ENV_NOT_RUNNABLE</code>，直到接收到 <code>user</code> 环境的 <code>ipc_send(fsreq)</code> 请求再变为可运行。</li><li><code>user</code> 环境向 <code>fs</code> 环境发送 <code>ipc_send(fsreq)</code> 请求来请求文件访问服务，请求后自身进入 <code>ENV_NOT_RUNNABLE</code> 状态等待响应。响应文件访问请求后，<code>ipc_send(dst_va)</code> 将请求结果发送回 <code>user</code> 环境，此时 <code>fs</code> 环境再次进入 <code>ENV_NOT_RUNNABLE</code> 状态等待下次请求处理。</li></ul><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><p>部分代码文件的主要功能（协调理解文件系统的核心框架）：</p><ul><li><code>tools</code> 目录中的文件是构建时的辅助工具的代码： <code>fsformat</code> 工具 —— 创建磁盘镜像</li><li><code>fs</code> 目录中存放的是文件系统处理相关的代码：通过 IPC 通信与用户进程 <code>user/lib/fsipc.c</code> 内的通信函数进行交互<ul><li><code>fs.c</code>：实现文件系统的基本功能函数</li><li><code>ide.c</code>：通过系统调用与磁盘镜像交互</li><li><code>serv.c</code>：进程的主干函数</li></ul></li><li><code>user/lib</code> 目录下存放了用户程序的库函数：<ul><li>系统用户程序库的一部分，抽象操作系统文件系统的文件，以及这些文件和信号源控制的文件。</li><li><code>fsipc.c</code>：实现与文件系统服务进程的交互</li><li><code>file.c</code>：实现文件系统的用户接口</li><li><code>fd.c</code>：实现文件描述符</li></ul></li></ul><p><strong>IDE磁盘驱动（外设控制）</strong>：</p><ul><li><p>在 MIPS 体系结构下，我们使用 MMIO（内存映射 IO）机制访问设备寄存器。MMIO 使用不同的物理内存地址为设备寄存器编址，将一部分对物理内存的访问 “重定向” 到设备地址空间中。CPU 对这部分物理内存的访问等同于对相应设备的访问。</p></li><li><p>外设是通过读写寄存器来进行数据通信，设备寄存器通常包括控制寄存器、状态寄存器和数据寄存器，这些寄存器被映射到指定的物理地址空间。</p></li></ul><p><strong>文件系统</strong>：</p><ul><li>磁盘布局：<br>MOS 以磁盘最开始的一个磁盘块当作引导扇区和分区表使用。接下来的一个磁盘块作为超级块（Super Block），用来描述文件系统的基本信息。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Super</span> &#123;</span><br> <span class="hljs-type">uint32_t</span> s_magic;   <span class="hljs-comment">// Magic number: FS_MAGIC</span><br> <span class="hljs-type">uint32_t</span> s_nblocks; <span class="hljs-comment">// Total number of blocks on disk</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">s_root</span>;</span> <span class="hljs-comment">// Root directory node</span><br> &#125;;<br></code></pre></td></tr></table></figure><ul><li>文件系统结构：</li></ul><p>磁盘抽象成由磁盘块组成，每个磁盘块由8个连续的扇区组成，扇区是物理上的结构，而磁盘块是逻辑上存在的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> &#123;</span> <span class="hljs-comment">//tools/fsformat.c</span><br><span class="hljs-type">uint8_t</span> data[BY2BLK];<br><span class="hljs-type">uint32_t</span> type;<br>&#125; disk[NBLOCK];<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br><span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span><br><span class="hljs-type">uint32_t</span> f_size; <span class="hljs-comment">// file size in bytes</span><br><span class="hljs-type">uint32_t</span> f_type; <span class="hljs-comment">// file type</span><br><span class="hljs-type">uint32_t</span> f_direct[NDIRECT];<br><span class="hljs-type">uint32_t</span> f_indirect;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory.</span><br><span class="hljs-type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];<br>&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed));<br></code></pre></td></tr></table></figure><p>上述定义了文件控制块，是整个文件系统需要理解的最关键的结构体，其中指明了文件的索引方式，文件控制块的大小，文件控制块的名称</p><p><strong>文件系统的用户接口</strong>：</p><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/lab5-3.PNG"><br>用户程序在发出文件系统操作请求时，将请求的内容放在对应的结构体中进行消息的传递，fs_serv 进程收到其他进行的 IPC 请求后，IPC 传递的消息包含了请求的类型和其他必要的参数，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果重新通过IPC反馈给用户程序。用户程序在发出文件系统操作请求时，将请求的内容放在对应的结构体中进行消息的传递，fs_serv 进程收到其他进行的 IPC 请求后，IPC 传递的消息包含了请求的类型和其他必要的参数，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果重新通过IPC馈给用户程序。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>lab5课下总体实验难度较大，涉及较多的结构体。同时综合了lab4的进程ipc问题。<br>我们首先需要弄明白每个结构体的作用，弄清楚文件系统抽象出来的结构体对应到哪一部分，结构体中的每个属性的作用。<br>其次，我们需要再次结合lab4的内容，搞清楚文件系统服务的函数调用过程，文件系统服务是一个单独的文件服务进程进行管理的，其他进程需要通过ipc与之通信，才能在进程中对文件进行操作。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab6</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab6/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab6/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>6.1</p><p>以下是修改的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> fildes[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> status;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    status = pipe(fildes);<br>    <br>    <span class="hljs-keyword">if</span>(status == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">switch</span>(fork())&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>            <span class="hljs-keyword">break</span>;<br>            <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <span class="hljs-comment">// 作为写者的子进程</span><br>         close(fildes[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 关闭不用的读端</span><br>            write(fildes[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Hello world\n&quot;</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 向管道中写入数据</span><br>            close(fildes[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 写入结束，关闭写端</span><br>            <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 作为读者的父进程</span><br>            close(fildes[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭不用的写端</span><br>            read(fildes[<span class="hljs-number">0</span>], buf, <span class="hljs-number">100</span>); <span class="hljs-comment">// 从管道中读数据</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father-process read:%s\n&quot;</span>, buf); <span class="hljs-comment">// 打印读出的数据</span><br>            close(fildes[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 读取结束，关闭读端</span><br>            <span class="hljs-built_in">exit</span>(EXIT_SUCESS);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>6.2</p><p>修改前的逻辑是：先对文件描述符(fd)进行映射引用，再对文件数据区(pipe)进行引用。这样会出现<code>pageref(fd)</code>比<code>pageref(pipe)</code>先进行更新的情况，也就是调用<code>dup</code>后<code>pageref(fd)</code>会比<code>pageref(pipe)</code>先加一。</p><p>如果子进程调用dup复制写端的文件描述符前，有<code>pageref(p[1]) == pageref(pipe) - 1</code>，而在dup中，如果p[1]已经被映射，而pipe还没被映射，此时转换到父进程运行，父进程调用<code>pipe_is_closed(p[1])</code>，判断此时的确满足<code>pageref(p[1]) == pageref</code>(pipe)，就会错误得出管道已经关闭的错误情况了。</p><p>6.3</p><p>我们通过<code>syscall</code>指令触发异常，在陷入内核态处理系统调用时，已经通过对<code>IEc</code>置0来关闭所有中断了，也就是说，系统调用是通过“关中断”实现的原子操作。</p><p>6.4</p><ol><li>可以解决。在任何情况下，必然存在不等式<code>page_ref(fd) &lt;= page_ref(pipe)</code>，而当我们重新设置<code>unmap</code>操作的顺序的话，在两次<code>unmap</code>中间对<code>pipe_close</code>进行中断的话，使得fd的引用次数先减少，则必然有<code>page_ref(fd) &lt; page_ref(pipe)</code>成立，因此不会在这个过程中对管道的开关过程发生误判。</li><li>会出现，见<strong>6.2</strong></li></ol><p>6.5</p><ol><li><p>用户进程调用<code>user/lib/files.c</code>文件中的<code>open</code>函数，其中又调用同文件夹下的<code>fsipc_open</code>函数,<code>fsipc_open</code>通过调用<code>fsipc</code>函数向服务进程进行进程间通信，并接收返回的消息。而相应的文件系统服务进程的<code>serve_open</code>函数调用<code>file_open</code>对文件进行打开操作，最终通过进程间通信实现与用户进程对文件描述符的共享。</p></li><li><p>在Lab3中填写了<code>load_icode</code>函数，实现了<code>ELF</code>可执行文件中读取数据并加载到内存空间，其中通过调用<code>elf_load_seg</code>函数来加载各个程序段。在Lab3 中我们要填写<code>load_icode_mapper</code>回调函数，在内核态下加载<code>ELF</code>数据到内存空间。</p></li><li></li></ol><ul><li><p><code>elf_load_seg</code>函数：在该函数处理程序的循环中，当处理到<code>.bss</code>段时，该函数会调用<code>map_page</code>把相应的虚拟地址映射到物理页上，但不会从文件中加载数据。而在<code>map_page</code>的内部会调用<code>load_icode_mapper</code>函数将页面进行映射并根据参数将内容置为0；</p></li><li><p><code>load_icode_mapper</code>函数：当处理到<code>.bss</code>段时，不从源数据中复制任何内容。最终调用<code>page_insert</code>函数将其置入页表并指定权限。该函数会根据传入的参数在页表项中建立映射关系，并初始化页面为0.</p></li></ul><p>6.6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// stdin should be 0, because no file descriptors are open yet</span><br> <span class="hljs-keyword">if</span> ((r = opencons()) != <span class="hljs-number">0</span>) &#123;<br>  user_panic(<span class="hljs-string">&quot;opencons: %d&quot;</span>, r);<br> &#125;<br> <span class="hljs-comment">// stdout</span><br> <span class="hljs-keyword">if</span> ((r = dup(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>  user_panic(<span class="hljs-string">&quot;dup: %d&quot;</span>, r);<br> &#125;<br></code></pre></td></tr></table></figure><p>在shell初始化的过程中有上述代码，设置了文件描述符的0和1分别为标准输入和标准输出。</p><p>6.7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;;) &#123;<br>  <span class="hljs-keyword">if</span> (interactive) &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n$ &quot;</span>);<br>  &#125;<br>  readline(buf, <span class="hljs-keyword">sizeof</span> buf);<br><br>  <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>   <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (echocmds) &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;# %s\n&quot;</span>, buf);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((r = fork()) &lt; <span class="hljs-number">0</span>) &#123;<br>   user_panic(<span class="hljs-string">&quot;fork: %d&quot;</span>, r);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>   runcmd(buf);<br>   <span class="hljs-built_in">exit</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   wait(r);<br>  &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>参照上述代码，在MOS中我们用到的shell命令除了<code>echocmds</code>和注释两种情况外，都需要<code>fork</code>一个子shell来处理输入的命令。</p><p>Linux的<code>cd</code>指令使用频率较高，若设置为外部指令必然会在<code>cd</code>的时候多次调用<code>fork</code>生成子进程，这显然是低效的。将其设置为内部指令可以切实提高我们操作系统的效率。</p><p>6.8</p><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab6/lab6-1.PNG" alt="spawn流程图"></p><ul><li>总共spawn了两次，分别是由最初被<code>fork</code>出的2803进程<code>spawn</code>出了3805进程，以及3004(被2803进程在<code>parsecmd</code>时<code>fork</code>得到)进程<code>spawn</code>出了4006进程。</li><li>观察到了四次进程销毁：<br>2803进程：由主shell进程fork出来的子shell进程，用于解析并执行当前命令；<br>3004进程：由2803进程fork出来的子进程，用于解析并执行管道右端的命令；<br>3805进程：由2803进程spawn出来的子进程，用于执行管道左边的命令；<br>4006进程：由3004进程spawn出来的子进程，用于执行管道右边的命令；</li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><ol><li><code>spawn</code>函数</li></ol><p>有点类似于fork函数的思路。</p><h4 id="Step-1-打开文件"><a href="#Step-1-打开文件" class="headerlink" title="Step 1: 打开文件"></a>Step 1: 打开文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd;<br><span class="hljs-keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打开要执行的程序文件。</li><li>如果打开失败，返回错误代码。</li></ul><h4 id="Step-2-读取-ELF-头"><a href="#Step-2-读取-ELF-头" class="headerlink" title="Step 2: 读取 ELF 头"></a>Step 2: 读取 ELF 头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> r;<br>u_char elfbuf[<span class="hljs-number">512</span>];<br><span class="hljs-keyword">if</span> ((r=readn(fd, elfbuf, <span class="hljs-keyword">sizeof</span>(Elf32_Ehdr)))&lt;<span class="hljs-number">0</span> || r!= <span class="hljs-keyword">sizeof</span>(Elf32_Ehdr)) &#123;<br>    <span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-type">const</span> Elf32_Ehdr *ehdr = elf_from(elfbuf, <span class="hljs-keyword">sizeof</span>(Elf32_Ehdr));<br><span class="hljs-keyword">if</span> (!ehdr) &#123;<br>    r = -E_NOT_EXEC;<br>    <span class="hljs-keyword">goto</span> err;<br>&#125;<br>u_long entrypoint = ehdr-&gt;e_entry;<br></code></pre></td></tr></table></figure><ul><li>从文件中读取 ELF 头部信息。</li><li>验证读取的数据是否正确且大小合适。</li><li>如果失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="Step-3-创建子进程"><a href="#Step-3-创建子进程" class="headerlink" title="Step 3: 创建子进程"></a>Step 3: 创建子进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int child;<br>child = syscall_exofork();<br><span class="hljs-keyword">if</span> (child &lt; <span class="hljs-number">0</span>) &#123;<br>    r = child;<br>    <span class="hljs-keyword">goto</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>syscall_exofork</code> 系统调用创建一个子进程。</li><li>如果创建失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="Step-4-初始化子进程的栈"><a href="#Step-4-初始化子进程的栈" class="headerlink" title="Step 4: 初始化子进程的栈"></a>Step 4: 初始化子进程的栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int sp;<br><span class="hljs-keyword">if</span> ((r = init_stack(child, argv, &amp;sp)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> err1;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>init_stack</code> 初始化子进程的栈。</li><li>如果初始化失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="Step-5-加载-ELF-段到子进程的内存中"><a href="#Step-5-加载-ELF-段到子进程的内存中" class="headerlink" title="Step 5: 加载 ELF 段到子进程的内存中"></a>Step 5: 加载 ELF 段到子进程的内存中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> ph_off;<br>ELF_FOREACH_PHDR_OFF (ph_off, ehdr) &#123;<br>    <span class="hljs-keyword">if</span> ((r = seek(fd, ph_off)) &lt; <span class="hljs-number">0</span> || (r = readn(fd, elfbuf, ehdr-&gt;e_phentsize)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> err1;<br>    &#125;<br>    Elf32_Phdr *ph = (Elf32_Phdr *)elfbuf;<br>    <span class="hljs-keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;<br>        <span class="hljs-type">void</span> *bin;<br>        <span class="hljs-keyword">if</span> ((r = read_map(fd, ph-&gt;p_offset, &amp;bin)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = elf_load_seg(ph, bin, spawn_mapper, &amp;child)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err1;<br>        &#125;<br>    &#125;<br>&#125;<br>close(fd);<br></code></pre></td></tr></table></figure><ul><li>遍历 ELF 文件的程序头表，查找需要加载的段。</li><li>使用 <code>read_map</code> 读取段内容到内存。</li><li>使用 <code>elf_load_seg</code> 将段内容加载到子进程的内存中。</li><li>如果失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="设置子进程的-Trapframe-和执行入口"><a href="#设置子进程的-Trapframe-和执行入口" class="headerlink" title="设置子进程的 Trapframe 和执行入口"></a>设置子进程的 Trapframe 和执行入口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">tf</span> =</span> envs[ENVX(child)].env_tf;<br>tf.cp0_epc = entrypoint;<br>tf.regs[<span class="hljs-number">29</span>] = sp;<br><span class="hljs-keyword">if</span> ((r = syscall_set_trapframe(child, &amp;tf)) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>设置子进程的 <code>Trapframe</code>，包括程序计数器和栈指针。</li><li>如果设置失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="共享页表条目"><a href="#共享页表条目" class="headerlink" title="共享页表条目"></a>共享页表条目</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (u_int pdeno = <span class="hljs-number">0</span>; pdeno &lt;= PDX(USTACKTOP); pdeno++) &#123;<br>    <span class="hljs-keyword">if</span> (!(vpd[pdeno] &amp; PTE_V)) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (u_int pteno = <span class="hljs-number">0</span>; pteno &lt;= PTX(~<span class="hljs-number">0</span>); pteno++) &#123;<br>        u_int pn = (pdeno &lt;&lt; <span class="hljs-number">10</span>) + pteno;<br>        u_int perm = vpt[pn] &amp; ((<span class="hljs-number">1</span> &lt;&lt; PGSHIFT) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> ((perm &amp; PTE_V) &amp;&amp; (perm &amp; PTE_LIBRARY)) &#123;<br>            <span class="hljs-type">void</span> *va = (<span class="hljs-type">void</span> *)(pn &lt;&lt; PGSHIFT);<br>            <span class="hljs-keyword">if</span> ((r = syscall_mem_map(<span class="hljs-number">0</span>, va, child, va, perm)) &lt; <span class="hljs-number">0</span>) &#123;<br>                debugf(<span class="hljs-string">&quot;spawn: syscall_mem_map %x %x: %d\n&quot;</span>, va, child, r);<br>                <span class="hljs-keyword">goto</span> err2;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共享页表条目中标记为 <code>PTE_LIBRARY</code> 的页。</li><li>将这些页映射到子进程中。</li></ul><h4 id="设置子进程状态为可运行"><a href="#设置子进程状态为可运行" class="headerlink" title="设置子进程状态为可运行"></a>设置子进程状态为可运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((r = syscall_set_env_status(child, ENV_RUNNABLE)) &lt; <span class="hljs-number">0</span>) &#123;<br>    debugf(<span class="hljs-string">&quot;spawn: syscall_set_env_status %x: %d\n&quot;</span>, child, r);<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将子进程的状态设置为可运行。</li><li>如果失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="错误处理部分"><a href="#错误处理部分" class="headerlink" title="错误处理部分"></a>错误处理部分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">err2:<br>    syscall_env_destroy(child);<br>    <span class="hljs-keyword">return</span> r;<br>err1:<br>    syscall_env_destroy(child);<br>err:<br>    close(fd);<br>    <span class="hljs-keyword">return</span> r;<br></code></pre></td></tr></table></figure><ul><li>如果任何步骤失败，销毁子进程并关闭文件描述符。</li><li>返回错误代码。</li></ul><p>这个函数通过一系列系统调用和 ELF 解析过程创建并初始化一个新的子进程。主要步骤包括打开可执行文件、读取 ELF 头部信息、创建子进程、初始化栈、加载 ELF 段、设置 Trapframe 和共享页表条目，最后将子进程状态设置为可运行。整个过程包括详细的错误处理，以确保在任何步骤失败时都能正确清理资源并返回适当的错误代码。</p><ol start="2"><li><code>parsecmd</code>函数</li></ol><h3 id="解析函数逻辑"><a href="#解析函数逻辑" class="headerlink" title="解析函数逻辑"></a>解析函数逻辑</h3><ol><li><p><strong>主循环</strong>：</p><ul><li>使用 <code>gettoken()</code> 函数获取下一个 token 的类型。</li><li>根据 token 的类型执行相应的操作。</li></ul></li><li><p><strong>gettoken() 函数</strong>：</p><ul><li>该函数返回当前 token 的类型，可以是 <code>0</code>（结束）、<code>&#39;w&#39;</code>（单词）、<code>&#39;&lt;&#39;</code>（输入重定向）、<code>&#39;&gt;&#39;</code>（输出重定向）、<code>&#39;|&#39;</code>（管道符号）。</li></ul></li><li><p><strong>处理逻辑</strong>：</p><ul><li><code>case 0</code>：结束条件，返回参数个数 <code>argc</code>。</li><li><code>case &#39;w&#39;</code>：将单词 <code>t</code> 存储到 <code>argv</code> 数组中，并增加 <code>argc</code>。</li><li><code>case &#39;&lt;&#39;</code>：处理输入重定向，打开文件 <code>t</code> 并复制到标准输入（0），处理错误情况。</li><li><code>case &#39;&gt;&#39;</code>：处理输出重定向，打开文件 <code>t</code> 并复制到标准输出（1），处理错误情况。</li><li><code>case &#39;|&#39;</code>：处理管道，创建管道 <code>p</code>，fork 子进程，子进程处理管道右侧，父进程处理管道左侧。</li></ul></li><li><p><strong>管道处理</strong>：</p><ul><li>创建管道 <code>p[2]</code>。</li><li>调用 <code>pipe(p)</code> 创建管道。</li><li><code>fork()</code> 函数创建子进程。</li><li>子进程中，关闭不需要的管道端，并递归调用 <code>parsecmd()</code> 处理管道右侧。</li><li>父进程中，关闭不需要的管道端，并返回当前命令的参数个数 <code>argc</code>。</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>使用 <code>debugf()</code> 输出错误消息。</li><li>使用 <code>exit()</code> 终止进程。</li></ul></li></ol><h1 id="体会感想"><a href="#体会感想" class="headerlink" title="体会感想"></a>体会感想</h1><p>比较轻松的一次lab，但是综合性也比较强，特别是后面两个函数比较复杂，涉及了之前的一些内容。</p><p>总之os告一段落了，自己对os有了整体的认识，但是具体到某个流程的分析，或许会有磕磕绊绊。收获很大。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统基础</title>
    <link href="/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个分布式系统是:<strong>一组独立的计算机</strong>，在用户看来是一个<strong>单一的连贯系统</strong>。其中，位于联网计算机上的硬件或软件组件仅通过传递消息来通信和协调其操作。</p><p>构造分布式系统的主要动机是<strong>资源共享</strong>和<strong>协同计算</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>资源共享</strong>：分布式系统中的多个节点可以共享资源（如计算能力、存储和网络带宽），并且这些资源可以被多个用户和应用程序访问。</p></li><li><p><strong>并发性</strong>：分布式系统允许多个用户和应用程序同时访问和操作系统中的资源。<strong>这种并发性是分布式系统设计的核心</strong>。</p></li><li><p><strong>透明性</strong>：用户和应用程序通常不需要关心资源的物理位置。分布式系统通过中间件和协议提供透明性，使得资源的访问和管理看起来像是在单一系统中进行。</p></li><li><p><strong>容错性</strong>：分布式系统能够在部分节点发生故障时继续运行。系统通常会实现冗余和备份机制，以确保高可用性。</p></li><li><p><strong>可扩展性</strong>：系统规模有一定规模的扩展，无论是资源还是用户，系统的性能保持在一定的水平。</p></li><li><p><strong>异构性</strong>：分布式系统可以由不同类型的计算机和操作系统组成，能够在异构环境中协同工作。</p></li><li><p><strong>没有全局时钟</strong>：每个机器的有各自的时间，没有办法做到统一，程序间的协调靠交换消息</p></li><li><p><strong>故障独立性</strong>：一些进程出现故障，并不能保证其它进程都能知道</p></li></ol><h3 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h3><p><img src="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/%E7%A1%80/image.png"></p><ol><li><p><strong>通信管理</strong>：分布式中间件提供了不同系统或服务之间的通信机制，支持异步消息传递、远程过程调用（RPC）等，简化了系统间的交互。</p></li><li><p><strong>负载均衡</strong>：通过分布式中间件，可以实现请求的负载均衡，将流量分配到多个服务实例上，提高系统的可用性和性能。</p></li><li><p><strong>事务管理</strong>：中间件可以提供分布式事务管理，确保多个服务之间的数据一致性。</p></li><li><p><strong>安全性</strong>：中间件可以提供安全机制，如身份验证和授权，确保只有经过授权的用户和服务可以访问特定资源。</p></li><li><p><strong>监控与管理</strong>：分布式中间件通常集成监控工具，帮助开发者和运维人员实时监控系统的健康状态和性能指标。</p></li><li><p><strong>容错与恢复</strong>：中间件可以实现故障检测和自动恢复机制，提高系统的可靠性和可用性。</p></li></ol><p>中间件的插入，实现了分布式系统对用户的透明性，用户不用再关注分布式系统底层的架构和通信，只需要调用中间层暴露出来的接口。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
