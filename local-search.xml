<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>os-lab0</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="0-1"><a href="#0-1" class="headerlink" title="0.1"></a>0.1</h3><p>README.txt位置:<br>cat Untracked.txt:位于Untracked区<br>cat Stage.txt：Staged区。<br>cat Modified.txt:modifed区。</p><h3 id="0-2"><a href="#0-2" class="headerlink" title="0.2"></a>0.2</h3><p>add the file 、stage the file 和<br>commit 分别对应的是 Git 里的 <code>git add,git add,git commit</code>命令</p><h3 id="0-3"><a href="#0-3" class="headerlink" title="0.3"></a>0.3</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.git</span> checkout -- print<span class="hljs-selector-class">.c</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.git</span> reset HEAD print<span class="hljs-selector-class">.c</span><br>git checkout -- print<span class="hljs-selector-class">.c</span><br><span class="hljs-number">3</span><span class="hljs-selector-class">.git</span> rm <span class="hljs-attr">--cached</span> hello.txt<br></code></pre></td></tr></table></figure><h3 id="0-4"><a href="#0-4" class="headerlink" title="0.4"></a>0.4</h3><p>用<code>git reset --hard</code> 进行版本回溯，功能很强大，但是一旦使用，就没有后悔药。</p><h3 id="0-5"><a href="#0-5" class="headerlink" title="0.5"></a>0.5</h3><p>执行结果：<br>1.在shell命令行中输出：<code>first</code><br>2.output.txt文件中为：<code>second</code><br>3.output.txt文件中为：<code>third</code><br>4.output.txt文件中为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">third<br>forth<br></code></pre></td></tr></table></figure><h3 id="0-6"><a href="#0-6" class="headerlink" title="0.6"></a>0.6</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">result中为：<br>Shell Start<span class="hljs-built_in">..</span>.<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">a</span>=1<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">b</span>=2<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">c</span>=a+b<br>c = 3<br>save c <span class="hljs-keyword">to</span> ./file1<br>save b <span class="hljs-keyword">to</span> ./file2<br>save a <span class="hljs-keyword">to</span> ./file3<br>save file1 file2 file3 <span class="hljs-keyword">to</span> file4<br>save file4 <span class="hljs-keyword">to</span> ./result<br>3<br>2<br>1<br></code></pre></td></tr></table></figure><p>test的第1行打印了Shell Start… test的第2行打印了set a&#x3D;1<br>test的第3行给变量a赋值为1 test的第4行打印了set b&#x3D;2<br>test的第5行给变量b赋值为2 test的第6行打印了set c&#x3D;a+b<br>test的第7行进行了c&#x3D;a+b的运算 test的第8行打印了c&#x3D;3<br>test的第9行打印了save c to .&#x2F;file1<br>test的第10行把c的值重定向到了file1中<br>test的第11行打印了save b to .&#x2F;file2<br>test的第12行把b的值重定向到了file2中<br>test的第13行打印了save a to .&#x2F;file3<br>test的第14行把a的值重定向到了file3中<br>test的第15行打印了save file1 file2 file3 to file4<br>test的17，18，19行把file1，file2，file3的内容全部重定向到了file4中<br>test的第20行打印了save file4 to .&#x2F;result<br>test的第21行把file4的内容重定向到了result中</p><h2 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2.难点分析"></a>2.难点分析</h2><ol><li>linux的shell界面不是直观的图形界面，而是用命令行进行所有的任务，一开始难以适应。</li><li>linux中有基本的命令，有许多的脚本命令，还有一些强大的工具命令，初学的命令较多，而且命令的不同参数有不同作用，容易搞混淆，这让不太熟练的初学者感到吃力。</li><li>对于Makefile的理解要到位，特别是不同target之间的依赖关系。</li><li>要学会熟练运用sed和awk等脚本语言的基础命令。</li></ol><p><img src="/img/lab0-1.png"></p><h2 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3.实验体会"></a>3.实验体会</h2><p>lab0我们主要对linux系统的命令行操作进行了简单的学习和熟悉。学习了GCC，Makefile，Git等等强大工具的基本使用。我能够明显体会到linux系统与windows系统的不同，Linux系统拥有强大的命令行工具和脚本语言，可以提高工作效率和灵活性。但强大的功能需要我们付出很高的学习成本，许多的命令需要多用多练，在脑中形成长期记忆，才能熟练掌握。<br>本次实验还带我们回忆了c语言和mips的内容，需要我们再一次回顾计组的内容，在学习OS的过程中起到承上启下的作用，也便于我们更好地理解OS的底层原理。</p><table><thead><tr><th align="left">git branch -l                   # 查看所有分支</th></tr></thead><tbody><tr><td align="left">git checkout <branch_name>      # 切换到指定分支</td></tr><tr><td align="left">git checkout -b <branch_name>   # 根据当前分支，新建一个分支并切换到该分支上</td></tr><tr><td align="left">git merge [<branch1>] <branch2> # 将branch2合并到branch1，省略branch1参数时表示合并到当前分支</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab1</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul><li>ld是链接器工具，用于将编译后的目标文件链接成可执行文件或共享库。</li><li>readelf是一个用于查看ELF格式文件（包括可执行文件、共享库等）的工具。它可以显示ELF文件的各个段、符号表、重定位表等信息，帮助用户了解可执行文件的结构和内容。</li><li>mips-linux-gnu-前缀通常用于指明目标架构为MIPS架构的Linux系统。</li><li>objdump -DS hello命令用于对名为hello的可执行文件进行反汇编，并显示汇编代码和符号表信息。下面是每个参数的含义：</li></ul><ol><li>objdump：用于显示目标文件信息的工具。</li><li>-D：指定显示反汇编代码。该选项会将目标文件中的机器指令反汇编成汇编代码并显示。</li><li>-S：指定同时显示源代码和反汇编代码。该选项会尝试将反汇编代码与源代码对应起来显示。<br>hello：要反汇编的目标文件的文件名。在这里是名为hello的可执行文件。<br>通过执行objdump -DS hello命令，可以查看hello可执行文件的反汇编代码和符号表信息，帮助理解程序的实现细节和结构。</li></ol><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p><img src="/img/lab1-1.png" alt="1"><br><img src="/img/lab1-2.PNG" alt="2"><br>通过 readelf -h命令，可以看到我们编写的readelf文件是ELF64，而hello文件是ELF32，我们编写的readelf文件只能够解析32位类型的文件，所以不能解析它本身。</p><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>因为上电是OS启动的第一个阶段，首先启动bootloader程序，在stage1阶段初始化硬件设备。此时对于MIPS处理器来说，MIPS体系结构上电时，启动入口的地址为0xBFC00000（或为某一个确定的地址）。<br>在stage2阶段，我们才将内核镜像加载到内存指定的位置，即内存布局图放置，我们可以从mips_init()跳转到正确的内核。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h3><p>难点在于理解elf.h文件中的结构体，以及理解ELF文件的结构。</p><p><img src="/img/lab1-4.PNG" alt="alt text"></p><h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2"></a>1.2</h3><p>根据内存示意图进行放置即可</p><h3 id="1-3-1"><a href="#1-3-1" class="headerlink" title="1.3"></a>1.3</h3><ul><li>于看懂printk代码所要实现的功能，理解参数和变量的含义。</li><li>注意是按照%[flags][width][.precision][length]specifier这样的顺序进行的<br><img src="/img/lab1-3.PNG" alt="alt text"></li></ul><h2 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h2><p>从lab1的实验，我们初步学到了os的启动过程。我们学会了如何把kernel放到内存正确的位置。还学习了ELF文件的格式。<br>在完成readelf练习的过程中，我感觉初次阅读ELF文件的源码有一定困难。</p><p>同时，对于指导书中的Makefile文件，我觉得阅读起来比较吃力，许多宏定义不熟悉，许多命令和参数也不认识。</p><p>在完成printk函数时，我卡了很久，在阅读各个文件源码后，才理解该函数的作用是实现printf的功能。同时对于提示中的flush the string ，即第二处需要补充的代码，我不能理解提示的要求，不知道out函数具体实现了什么功能。还有在完成print_num的时候，对于neg_flag的判断也卡了一下。</p><p>我认为需要稳固c语言和mips的基础，增强代码的阅读能力，才能更好的理解os实验的源码。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,Makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab2</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>在编写的 C 程序中，指针变量中存储的地址被视为<strong>虚拟地址</strong><br>MIPS汇编程序中<code>lw</code>和<code>sw</code>指令使用的地址被视为<strong>虚拟地址</strong></p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><ol><li></li></ol><p>使用宏来实现链表具有以下好处：<br>用宏实现链表，可以避免重复劳动，因为宏没有规定返回值的类型。<br>2.<br>单向链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n)；<br>循环链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n)；<br>双向链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(1)；</p><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p>正确的结构选C</p><h3 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h3><ol><li></li></ol><ul><li>ASID可以唯一标识每个进程，可以为该进程提供地址空间保护，当TLB尝试解析虚拟页码时，它确保当前正在运行的进程的ASID与与虚拟页面关联的ASID匹配。</li><li>同时也使得不同的虚拟地址空间可以映射到同一块物理地址，有利于提高CPU的利用率。</li></ul><ol start="2"><li></li></ol><p>4kc中ASID的位数为8位，说明可容纳不同地址的空间的最大数量位为$2^8$</p><h3 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h3><p><code>tlb_invalidate</code> 调用了<code>tlb_out</code><br><code>tlb_invalidate</code> 函数实现删除特定虚拟地址在TLB<br>中的旧表项</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mips">LEAF(tlb_out)<br><span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI //将 <span class="hljs-built_in">EntryHi</span>中key加载到寄存器<span class="hljs-built_in">t0</span>中<br> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">a0</span>, CP0_ENTRYHI//将旧表项Key写入<span class="hljs-built_in">EntryHi</span><br> <span class="hljs-keyword">nop//空指令</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">tlbp </span>//根据<span class="hljs-built_in">EntryHi</span>中的Key查找对应的旧表项，将表项的索引存入Index<br> <span class="hljs-keyword">nop//空指令</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t1</span>, CP0_INDEX //将旧表项的索引存入<span class="hljs-built_in">t1</span>寄存器<br><span class="hljs-meta">.set</span> reorder<br> <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">t1</span>, NO_SUCH_ENTRY //如果<span class="hljs-built_in">t1</span>的值为负，则跳转到标签NO_SUCH_ENTRY处<br><span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYHI //否则，向<span class="hljs-built_in">EntryHi</span>寄存器写入<span class="hljs-number">0</span><br> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO0//向<span class="hljs-built_in">EntryLo0</span>寄存器写入<span class="hljs-number">0</span><br> <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO1//向<span class="hljs-built_in">EntryLo1</span>寄存器写入<span class="hljs-number">0</span><br> <span class="hljs-keyword">nop </span>  //空指令<br> <span class="hljs-keyword">tlbwi </span>//将<span class="hljs-built_in">EntryHi</span>和<span class="hljs-built_in">EntryLo0</span>、<span class="hljs-built_in">EntryLo1</span>中的值写入索引指定的表项<br><span class="hljs-meta">.set</span> reorder<br></code></pre></td></tr></table></figure><h3 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h3><ul><li><p>MIPS主要采用的是页式管理系统，X86主要采用的是段页式。</p></li><li><p>MIPS 会触发TLB Refill 异常，内核的 tlb_refill_handler 会以 pgd_current 为当前进程的 PGD 基址，索引获得转换失败的虚址对应的 PTE，并将其填入 TLB，完了CPU 把刚刚转换失败的虚地址再走一下 TLB 就OK了。而 X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。</p></li><li><p>另外转换失败的虚址，MIPS 使用 BadVAddr 寄存器存放，X86 使用 CR2 存放。</p></li></ul><h3 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h3><p>三级页表页目录的基地址为：<br> $PT_{base}|PT_{base}&gt;&gt;9|PT_{base}&gt;&gt;18$</p><p>映射到页目录自身的页目录项:<br> $PT_{base}|PT_{base}&gt;&gt;9|PT_{base}&gt;&gt;18|PT_{base}&gt;&gt;27$</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><ol><li>对于双向链表的理解：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name, type)                                                                      \</span><br><span class="hljs-meta"> struct name &#123;                                                                              \</span><br><span class="hljs-meta">  struct type *lh_first; <span class="hljs-comment">/* first element */</span>                                         \</span><br><span class="hljs-meta"> &#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                                           \</span><br><span class="hljs-meta"> struct &#123;                                                                                   \</span><br><span class="hljs-meta">  struct type *le_next;  <span class="hljs-comment">/* next element */</span>                                          \</span><br><span class="hljs-meta">  struct type **le_prev; <span class="hljs-comment">/* address of previous next element */</span>                      \</span><br><span class="hljs-meta"> &#125;</span><br><br>LIST_HEAD(Page_list, Page);<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br> Page_LIST_entry_t pp_link; <span class="hljs-comment">/* free list link */</span><br><br> <span class="hljs-comment">// Ref is the count of pointers (usually in page table entries)</span><br> <span class="hljs-comment">// to this page.  This only holds for pages allocated using</span><br> <span class="hljs-comment">// page_alloc.  Pages allocated at boot time using pmap.c&#x27;s &quot;alloc&quot;</span><br> <span class="hljs-comment">// do not have valid reference count fields.</span><br><br> u_short pp_ref;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>根据上述定义代码可以很好的理解页中双向链表的结构。</p><ol start="2"><li>难点在于二级页表的查询机制和相关函数的理解：<br><img src="/img/lab2-2.PNG"><br>重点在于对pgdir_walk函数的理解，该函数构建了虚拟地址对应的一级页目录项和二级页表的对应关系。其中对于指针所指向的地址理解也十分重要<br><img src="/img/lab2-1.PNG"><br>参考上图<br>pgdir代表的是一级页表基地址<br>pgdir_entryp则是代表查询的页目录项地址<br>*pgdir_entryp存的则是对应二级页表的物理页号和权限位<br>*ppte存的则是该页对应的二级页表项的地址。</li></ol><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab2实验的整体难度较高，涉及了mips的内存管理。尤其是其中的二级页表和快表机制在实际写代码时比较绕，自映射也很难理解，花费了大量时间和精力理解。同时需要完成的内容较多，主要涉及了c语言的指针，容易搞混。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab3</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h3><p><code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code>中，</p><p><code>UVPT</code>：用户页表的起始处的内核虚拟地址</p><p><code>PDX(UVPT)</code>：UVPT所处的页目录号（即 UVPT 处于第 PDX(UVPT) 个页目录项所映射的4MB空间；联系 UVPT 的含义，因此页目录也被第PDX(UVPT)映射）</p><p><code>e-&gt;env_pgdir</code>：进程 e 的页目录的内核虚拟地址</p><p><code>PADDR(e-&gt;env_pgdir)</code>：进程 e 的页目录的物理地址</p><p><code>PADDR(e-&gt;env_pgdir) | PTE_V</code>：页目录的物理基地址加上权限位</p><p>页目录基地址&#x3D;<code>UVPT+UVPT&gt;&gt;10</code></p><p>页目录的Page number&#x3D;<code>(UVPT+UVPT&gt;&gt;10)&gt;&gt;12</code>;</p><p>页目录中<strong>映射到页目录基地址</strong>的<strong>项A的地址</strong>&#x3D;<code>UVPT+Page number*4=UVPT+UVPT&gt;&gt;10+UVPT&gt;&gt;20</code></p><p>页表项A所在的页目录号&#x3D;（项的地址-页目录基地址）&#x2F;4&#x3D;<code>UVPT&gt;&gt;20&gt;&gt;2</code>&#x3D;<code>PDX(UVPT)</code>  </p><p><code>e-&gt;env_pgdir[PDX(UVPT)]</code>:代表项A中存储的物理页号和权限位，即页目录的物理基地址加权限位</p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p><code>data</code>是传入的进程控制块指针，在<code>load_icode_mapper</code>中有<code>struct Env *env = (struct Env *)data;</code><br>在建立虚拟地址到物理地址的页表映射的时候提供<code>env_pgdir</code>和<code>env_asid</code>；<br>如果没有<code>data</code>，<code>load_icode_mapper</code>就不能知道当前进程空间的页目录基地址和asid。</p><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p><img src="/img/lab3-1.PNG"></p><ol><li>若<code>va</code>不按照<code>PAGE_SIZE</code>对齐，算出<code>offset</code>，将<code>offset</code>中的<code>bin</code>数据写入对应的内存地址并建立页表映射关系。</li><li>将段内的每一页数据写入对应的内存地址并建立页表的映射关系。</li><li>若发现段在内存的大小<code>sg_size</code>大于在ELF文件中的大小<code>bin_size</code>，则需要把多余的空间用0填充满</li></ol><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><p>这里的<code>env_tf.cp0_epc</code>字段指示了进程恢复运行时PC应恢复到的位置，对于CPU来说，cpu直接接触的地址是虚拟地址，所以<code>env_tf.cp0_epc</code>中存的是虚拟地址</p><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p><code>handle_int</code>在<code>genex.S</code>中用mips宏定义实现，而<code>handle_mod</code>和<code>handle_tlb</code>中在<code>genex.S</code>仅仅有宏定义，实际在函数<code>do_tlb_mod</code>和<code>do_tlb_refill</code>中实现。</p><h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>在这段代码中，时钟中断的开启和关闭是通过对 <code>CP0_CAUSE</code> 寄存器和 <code>CP0_STATUS</code> 寄存器进行操作来实现的。</p><p><code>时钟中断的开启</code>：<br>MOS中，时钟中断的初始化发生在调度执行每一个进程之前。从代码角度，就是在<code>env_pop_tf</code>中调用了宏<code>RESET_KCLOCK</code>，随后又在宏 <code>RESTORE_ALL</code> 中恢复了 Status 寄存器，开启了中断。</p><p><code>时钟中断的关闭</code>：<br>在<code>.text.exc_gen_entry</code>处将UM、EXL和IE位清零，确保处理器处于内核模式，并且禁用中断。</p><h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><p>进程装在两个队列中，一次运行一个进程。定时器周期性产生中断，使得当前进程被迫停止，进入<code>.text.exc_gen_entry</code>，逐步执行到<code>schedule</code>调度函数,若该进程时间片还未用完，则可用时间片数量－1，继续执行该进程，否则会切换到下一个进程，保存上下文，并将原来的进程送到调度队列的末尾，若进程不处于RUNNABLE状态，则会进行其他处理。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><ol><li>进程的创建</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Control block of an environment (process).</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span> <span class="hljs-comment">// saved context (registers) before switching</span><br>LIST_ENTRY(Env) env_link; <span class="hljs-comment">// intrusive entry in &#x27;env_free_list&#x27;</span><br>u_int env_id; <span class="hljs-comment">// unique environment identifier</span><br>u_int env_asid; <span class="hljs-comment">// ASID of this env</span><br>u_int env_parent_id; <span class="hljs-comment">// env_id of this env&#x27;s parent</span><br>u_int env_status; <span class="hljs-comment">// status of this env</span><br>Pde *env_pgdir; <span class="hljs-comment">// page directory</span><br>TAILQ_ENTRY(Env) env_sched_link; <span class="hljs-comment">// intrusive entry in &#x27;env_sched_list&#x27;</span><br>u_int env_pri; <span class="hljs-comment">// schedule priority</span><br><br><span class="hljs-comment">// Lab 4 IPC</span><br>u_int env_ipc_value;   <span class="hljs-comment">// the value sent to us</span><br>u_int env_ipc_from;    <span class="hljs-comment">// envid of the sender</span><br>u_int env_ipc_recving; <span class="hljs-comment">// whether this env is blocked receiving</span><br>u_int env_ipc_dstva;   <span class="hljs-comment">// va at which the received page should be mapped</span><br>u_int env_ipc_perm;    <span class="hljs-comment">// perm in which the received page should be mapped</span><br><br><span class="hljs-comment">// Lab 4 fault handling</span><br>u_int env_user_tlb_mod_entry; <span class="hljs-comment">// userspace TLB Mod handler</span><br><br><span class="hljs-comment">// Lab 6 scheduler counts</span><br>u_int env_runs; <span class="hljs-comment">// number of times we&#x27;ve been env_run&#x27;ed</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在本次实验中，PCB控制块实则以Env的结构体体现出来，实验中前几个函数都涉及到这个结构体的内容，需要认真理解。</p><ol start="2"><li>加载二进制镜像到内存中<br><img src="/img/lab3-2.PNG" alt="alt text"></li></ol><ul><li><p>其中<code>load_icode</code>函数的理解较难，调用了<code>elf_load_seg</code>函数，需要理解ELF文件的段是如何加载到内存中的。这里的情况较为复杂，首先需要考虑虚拟地址对齐的问题，其次还需要考虑段在文件中的大小和在内存中的大小问题，如果前者小于后者，需要进行补0操作。</p></li><li><p>同时，这里也涉及lab2内存管理的一些内容，我们需要调用<code>page_alloc</code>,<code>page_insert</code>等函数，用页的方式加载段到内存中，同时建立起页表中虚拟地址和物理地址的映射关系。</p></li></ul><ol><li>时钟中断机制的理解</li></ol><p><img src="/img/lab3-3.PNG"><br>这里涉及的函数较多，还涉及很多mips的宏定义和函数定义，理解起来十分复杂。需要根据时钟中断的步骤来理清每个函数的调用过程。</p><ul><li><code>RESET_KCLOCK</code> 宏将 Count 寄存器清零并将 Compare 寄存器配置为我们所期望的计时器周期数，这就对Timer完成了配置。在设定个时钟周期后，时钟中断将被触发。</li><li>MOS中，时钟中断的初始化发生在调度执行每一个进程之前。从代码角度，就是在<code>env_pop_tf</code>中调用了宏<code>RESET_KCLOCK</code>，随后又在宏 <code>RESTORE_ALL</code> 中恢复了 Status 寄存器，开启了中断。</li><li>一旦时钟中断产生，就会触发4KC硬件的异常中断处理流程。系统将 PC指向 <code>0x80000180</code>，<br>跳转到<code>.text.exc_gen_entry</code> 代码段执行。对于时钟引起的中断，通过<code>.text.exc_gen_entry</code>代码段的分发，最终会调用<code>handle_int</code> 函数进行处理。</li><li><code>handle_int</code> 函数根据 Cause 寄存器的值判断是否是 Timer 对应的 7 号中断位引发的时钟中断，如果是，则执行中断服务函数 <code>timer_irq</code>，跳转到 <code>schedule</code> 中执行。</li><li><code>schedule</code>根据不同的中断类型调用不同的处理函数，再调用<code>env_run</code>运行进程。</li></ul><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>lab3的课下实验相较于lab2较为简单，但是进程的机制理解起来比较复杂，涉及到内存管理，进程切换，进程创建等方方面面。其中特别是对进程调度的核心算法和流程的理解十分重要。</p><p><strong>对于进程调度的总结</strong>：<br><code>e-&gt;env_pri</code> ： 进程每次运行的时间片数量；</p><p><code>curenv</code>全局变量：当前正在运行的进程（在第一 个进程被调度前为 NULL）；</p><p><code>count</code>静态变量：当前正在运行进程的剩余时间片数量 &#x3D; 当前进程剩余的执行次数；</p><p><code>env_sched_list</code>调度队列：存在且只存在所有就绪（状态为 <code>ENV_RUNNABLE</code>）的进程，其中也需要包括正在运行的进程；</p><p>当满足下列条件中的任意一个时，需要进程切换：</p><ul><li>尚未调度过任何进程（<code>curenv == NULL</code>）</li><li>当前进程已经用完了时间片（<code>count == 0</code>）</li><li>当前进程不再就绪，如：被阻塞或退出（<code>e-&gt;env_status != ENV_RUNNABLE</code>）</li><li><code>yield</code> 参数指定必须发生切换（<code>yield != 0</code>）</li><li>无需进程切换时，将剩余时间片数量 <code>count</code> 减去 1，然后调用 <code>env_run</code> 函数；</li></ul><p>需要进程切换时，判断当前进程是否仍然就绪，如果是则将其移动到调度链表的尾部。之后，我们选中调度链表首部的进程来调度运行，将剩余时间片数量设置为其优先级。</p><p>调度函数 <code>schedule</code> 以及其中逐级调用的 <code>env_run、env_pop_tf</code> 和 <code>ret_from_exception</code> 函数都是不返回（no return）的函数，被调用后会从内核跳转到被调度进程的用户程序中执行。在 MIPS 中通常使用 j 指令而非 jal 调用不返回的函数，因为它们不会再返回到其调用者。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab4</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab4/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><p>4.1</p><ol><li><code>内核在保存现场的时候是如何避免破坏通用寄存器的？</code></li></ol><p>保存现场过程中，先通过<code>k0</code>寄存器暂存<code>sp</code>栈指针的值，之后将其余通用寄存器的值直接存到<code>cp</code>的协寄存器中。</p><ol start="2"><li><code>系统陷入内核调用后可以直接从当时的`$a0-$a3`参数寄存器中得到用户调用`msyscall`留下的信息吗？</code></li></ol><p>可以。从用户函数<code>syscall_*()</code>到内核函数<code>sys_*()</code>时，<code>$a1-$a3</code>未改变,<code>$a0</code>在<code>handle_sys()</code>的时候被修改为内核函数的地址，但在内核函数<code>sys_*()</code>仅为占位符，不会被用到。</p><ol start="3"><li><code>我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？</code></li></ol><p>用户调用时的参数：用户进程的寄存器现场(保存在了内核栈的<code>TF_5-TF_7</code>)的<code>$a1-$a3</code>;用户栈的参数<code>$a4$a5</code><br>把上面两部分参数分别拷贝至<code>arg1-arg5</code>,在sys函数中作为参数传入。</p><ol start="4"><li><code>内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是什么？</code></li></ol><p>对<code>Trapframe</code>结构体中的<code>cp0_epc</code>的值增加了4，并将<code>sys</code>开头函数的返回值存入<code>v0</code>寄存器，保证了系统调用后用户态进程可以获得正确的返回值，并且从触发系统调用的下一条指令继续执行。</p><p>4.2<br>判断<code>e-&gt;env_id != envid</code>的情况是为了确保所请求的<code>envid</code>与找到的环境的实际ID匹配。如果没有这个检查，可能将错误的<code>env</code>分配给<code>*penv</code></p><p>4.3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!envid)&#123;<br>  *penv=curenv;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<span class="hljs-keyword">else</span>&#123;<br>  e=&amp;envs[ENVX(envid)];<br> &#125;<br> <span class="hljs-keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;<br>  <span class="hljs-keyword">return</span> -E_BAD_ENV;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>从<code>envid2env</code>函数中可以看出，<code>curenv</code>分配的<code>envid</code>为0，因此，0用来作为目前运行进程的特判符。所以在给<code>env</code>分配<code>envid</code>时，使用的<code>mkenvid</code>返回值不能为0。</p><p>4.4</p><p>C</p><p>4.5</p><p><code>USTACKTOP</code>以下的应该映射。<br>但是<code>UTEMP</code>之下的<code>invalid memory</code> 是为处理页写入异常时做缓冲区用的，不需要共享。<br><code>UTOP</code>以上页面的内存与页表是所有进程共享的，且用户进程无权限访问，不需要做父子进程间的<code>duppage</code>。</p><p>4.6</p><ul><li>vpt和vpd分别代表页表项数组和页目录项数组，可以使用<code>vpt[index]</code>和<code>vpd[index]</code>的方式去访问页表项和页目录项。</li><li>由于用户进程下的系统调用的虚拟内存管理的函数传入的pgdir均为env结构体的kuseg的进程页目录，并且env_setup_vm()时把页目录进行自映射e-&gt;env_pgdir[PDX(UVPT)] &#x3D; e-&gt;env_cr3，所以实现了用户进程的虚拟内存管理，可以通过两级页表机制访问。<br>-参考vpt和vpd的定义代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vpt ((const volatile Pte *)UVPT) <span class="hljs-comment">//它将 UVPT（用户虚拟页表基址）转换为 Pte 类型的指针。</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))<span class="hljs-comment">//虚拟页目录基址转换为页目录项</span></span><br></code></pre></td></tr></table></figure><p>其中<code>vpd</code>的定义体现了页目录自映射。</p><p>-可以，因为在pmap.c中实现的虚拟内存机制，给页表项和页目录项的perm均为可写。</p><p>4.7</p><ul><li>注意以下代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (tf-&gt;regs[<span class="hljs-number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="hljs-number">29</span>] &gt;= UXSTACKTOP) &#123;<br> tf-&gt;regs[<span class="hljs-number">29</span>] = UXSTACKTOP;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，这里实现了类似“异常重入”的机制，即sp指针已经位于用户异常栈，即此时已经发生<code>tlb_mod</code>异常时，当再次发生相同的异常，重新将sp指向栈顶，会发生这种“异常重入”。</p><ul><li><code>tlb_mod</code>的异常处理比较特殊，真正的核心处理函数为<code>cow_entry()</code>，而这个函数位于用户态空间，也就是说，我们实际是在用户态进行异常处理的核心部分，所以我们需要将异常的现场<code>Trapframe</code>复制到用户空间，方便处理完异常后恢复现场。</li></ul><p>4.8</p><p>解放内核，不用内核执行大量的页面拷贝工作。同时符合MIPS4KC的微内核设计，将一些功能放到用户空间实现，提高了内核的稳定性和可移植性。</p><p>4.9</p><ul><li><p>第一次<code>syscall_set_tlb_mod_entry</code>是针对父进程设置的。子进程 <code>RUNNABLE</code> 后会从 <code>syscall_exo_fork</code> 逐级调用的 syscall 指令之后开始执行。如果在 <code>syscall_exo_fork</code> 之后再 <code>syscall_set_tlb_mod_entry</code>，那么子进程也会执行这个系统调用。</p></li><li><p>父进程运行时在函数调用等情形下会修改栈。在栈空间的页面标记为写时复制之后，父进程继续运行并修改栈，就会触发 TLB Mod 异常。所以在写时复制保护机制完成之前就需要 <code>syscall_set_tlb_mod_entry</code>。</p></li></ul><h2 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2.难点分析"></a>2.难点分析</h2><ol><li>系统调用<br>对于系统调用中几个函数调用顺序的理解。<br><img src="/img/lab4-1.PNG" alt="alt text"><br>系统调用本身是为了陷入内核态，因为一些操作只能在内核态实现。<br>其中从用户态到内核态的函数传参较难理解。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_syscall</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span> &#123;<br> <span class="hljs-type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);<br> <span class="hljs-type">int</span> sysno = tf-&gt;regs[<span class="hljs-number">4</span>];<br> <span class="hljs-keyword">if</span> (sysno &lt; <span class="hljs-number">0</span> || sysno &gt;= MAX_SYSNO) &#123;<br>  tf-&gt;regs[<span class="hljs-number">2</span>] = -E_NO_SYS;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br><br> <span class="hljs-comment">/* Step 1: Add the EPC in &#x27;tf&#x27; by a word (size of an instruction). */</span><br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (1/4) */</span><br> tf-&gt;cp0_epc+=<span class="hljs-number">4</span>;<br> <span class="hljs-comment">/* Step 2: Use &#x27;sysno&#x27; to get &#x27;func&#x27; from &#x27;syscall_table&#x27;. */</span><br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (2/4) */</span><br> func=syscall_table[sysno];<br> <span class="hljs-comment">/* Step 3: First 3 args are stored in $a1, $a2, $a3. */</span><br> u_int arg1 = tf-&gt;regs[<span class="hljs-number">5</span>];<br> u_int arg2 = tf-&gt;regs[<span class="hljs-number">6</span>];<br> u_int arg3 = tf-&gt;regs[<span class="hljs-number">7</span>];<br><br> <span class="hljs-comment">/* Step 4: Last 2 args are stored in stack at [$sp + 16 bytes], [$sp + 20 bytes]. */</span><br> u_int arg4, arg5;<br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (3/4) */</span><br> arg4=*(u_int *)(tf-&gt;regs[<span class="hljs-number">29</span>]+<span class="hljs-number">16</span>);<br> arg5=*(u_int *)(tf-&gt;regs[<span class="hljs-number">29</span>]+<span class="hljs-number">20</span>);<br> <span class="hljs-comment">/* Step 5: Invoke &#x27;func&#x27; with retrieved arguments and store its return value to $v0 in &#x27;tf&#x27;.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-comment">/* Exercise 4.2: Your code here. (4/4) */</span><br> tf-&gt;regs[<span class="hljs-number">2</span>]=func(arg1,arg2,arg3,arg4,arg5);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们通过Trapframe结构体保存了用户现场的上下文，以此在内核态进行传参，同时再通过<strong>系统调用处理函数表</strong>跳转到具体的调用函数，同时又在tf-&gt;regs[2]中，即v0寄存器中保存系统调用的返回值。</p><ol><li>进程间IPC通信</li></ol><p>这里的主要难点在于集中了对lab3和lab4前半部分的的综合理解运用，涉及了进程间的切换和系统调用。</p><p><img src="/img/lab4-2.PNG" alt="alt text"></p><p>按照上述的图示去理解ipc的通信过程，即一个进程先发出<code>ipc_recv</code>的信号之后，再调用<code>schedule(1)</code>切换到另一个进程进行<code>ipc_send</code>，从而实现两个进程间的通信。</p><ol><li>fork的实现</li></ol><p>首先要理解函数<code>duppage()</code>，这是实现父进程将地址空间中需要与子进程共享的页面映射给子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">syscall_mem_map(<span class="hljs-number">0</span>, addr, envid, addr, perm);<span class="hljs-comment">//先将子进程映射到父进程映射的物理页实现共享</span><br><span class="hljs-keyword">if</span>(r)<br>syscall_mem_map(<span class="hljs-number">0</span>,addr,<span class="hljs-number">0</span>,addr,perm);<span class="hljs-comment">//再用新的映射覆盖自己旧的映射改变权限位</span><br></code></pre></td></tr></table></figure><p>同时注意先修改子进程的权限，如果先直接映射自身，那么权限位改为PTE_COW后，无法再对子进程进行映射（会陷入写时异常，还没有实现）</p><p>我们还需要注意fork中涉及处理页写入异常，这是一种特殊的异常，异常处理的核心函数<code>cow_entry()</code>是在用户态下调用的。<br>函数中<code>memcpy((void*)UCOW,(void*)ROUNDDOWN(va,PAGE_SIZE),PAGE_SIZE);</code>复制写时错误页的信息，需要进行向下对齐，本质上是将地址的后12位清0，得到页号。</p><p>fork函数在进行映射之前，一定要查询页目录项和页表项是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; VPN(USTACKTOP); i++) &#123;<br>  <span class="hljs-keyword">if</span> ((vpd[i &gt;&gt; <span class="hljs-number">10</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;<br>   duppage(child, i);<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>fork函数是由父进程进行调用的，但是却有两个返回值，这是因为子进程的返回值：<code>e-&gt;env_tf.regs[2]=0;</code>,即保留在v0寄存器中。</p><h2 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3.实验体会"></a>3.实验体会</h2><p>涉及不同进程之间的操作以及系统调用，这部分内容综合了整个前面的lab，难度较大，需要对OS有深刻的认识。</p><p>课下需要填写的内容较多，分散在不同的文件，实则上如果从os的涉及来看，各个文件的代码是联系紧密的。</p><p>课上上机考察十分细致，需要对整个系统调用的过程和进程之间的ipc的工作过程有清晰的认识，要理解函数之间的调用关系。</p><p>要时刻注意区分<strong>内核态</strong>和<strong>用户态</strong>，这样在补充函数时不会出现一些奇奇怪怪的bug。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab6</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab6/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab6/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>6.1</p><p>以下是修改的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> fildes[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> status;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    status = pipe(fildes);<br>    <br>    <span class="hljs-keyword">if</span>(status == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">switch</span>(fork())&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>            <span class="hljs-keyword">break</span>;<br>            <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <span class="hljs-comment">// 作为写者的子进程</span><br>         close(fildes[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 关闭不用的读端</span><br>            write(fildes[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Hello world\n&quot;</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 向管道中写入数据</span><br>            close(fildes[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 写入结束，关闭写端</span><br>            <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>        <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 作为读者的父进程</span><br>            close(fildes[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭不用的写端</span><br>            read(fildes[<span class="hljs-number">0</span>], buf, <span class="hljs-number">100</span>); <span class="hljs-comment">// 从管道中读数据</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father-process read:%s\n&quot;</span>, buf); <span class="hljs-comment">// 打印读出的数据</span><br>            close(fildes[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 读取结束，关闭读端</span><br>            <span class="hljs-built_in">exit</span>(EXIT_SUCESS);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>6.2</p><p>修改前的逻辑是：先对文件描述符(fd)进行映射引用，再对文件数据区(pipe)进行引用。这样会出现<code>pageref(fd)</code>比<code>pageref(pipe)</code>先进行更新的情况，也就是调用<code>dup</code>后<code>pageref(fd)</code>会比<code>pageref(pipe)</code>先加一。</p><p>如果子进程调用dup复制写端的文件描述符前，有<code>pageref(p[1]) == pageref(pipe) - 1</code>，而在dup中，如果p[1]已经被映射，而pipe还没被映射，此时转换到父进程运行，父进程调用<code>pipe_is_closed(p[1])</code>，判断此时的确满足<code>pageref(p[1]) == pageref</code>(pipe)，就会错误得出管道已经关闭的错误情况了。</p><p>6.3</p><p>我们通过<code>syscall</code>指令触发异常，在陷入内核态处理系统调用时，已经通过对<code>IEc</code>置0来关闭所有中断了，也就是说，系统调用是通过“关中断”实现的原子操作。</p><p>6.4</p><ol><li>可以解决。在任何情况下，必然存在不等式<code>page_ref(fd) &lt;= page_ref(pipe)</code>，而当我们重新设置<code>unmap</code>操作的顺序的话，在两次<code>unmap</code>中间对<code>pipe_close</code>进行中断的话，使得fd的引用次数先减少，则必然有<code>page_ref(fd) &lt; page_ref(pipe)</code>成立，因此不会在这个过程中对管道的开关过程发生误判。</li><li>会出现，见<strong>6.2</strong></li></ol><p>6.5</p><ol><li><p>用户进程调用<code>user/lib/files.c</code>文件中的<code>open</code>函数，其中又调用同文件夹下的<code>fsipc_open</code>函数,<code>fsipc_open</code>通过调用<code>fsipc</code>函数向服务进程进行进程间通信，并接收返回的消息。而相应的文件系统服务进程的<code>serve_open</code>函数调用<code>file_open</code>对文件进行打开操作，最终通过进程间通信实现与用户进程对文件描述符的共享。</p></li><li><p>在Lab3中填写了<code>load_icode</code>函数，实现了<code>ELF</code>可执行文件中读取数据并加载到内存空间，其中通过调用<code>elf_load_seg</code>函数来加载各个程序段。在Lab3 中我们要填写<code>load_icode_mapper</code>回调函数，在内核态下加载<code>ELF</code>数据到内存空间。</p></li><li></li></ol><ul><li><p><code>elf_load_seg</code>函数：在该函数处理程序的循环中，当处理到<code>.bss</code>段时，该函数会调用<code>map_page</code>把相应的虚拟地址映射到物理页上，但不会从文件中加载数据。而在<code>map_page</code>的内部会调用<code>load_icode_mapper</code>函数将页面进行映射并根据参数将内容置为0；</p></li><li><p><code>load_icode_mapper</code>函数：当处理到<code>.bss</code>段时，不从源数据中复制任何内容。最终调用<code>page_insert</code>函数将其置入页表并指定权限。该函数会根据传入的参数在页表项中建立映射关系，并初始化页面为0.</p></li></ul><p>6.6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// stdin should be 0, because no file descriptors are open yet</span><br> <span class="hljs-keyword">if</span> ((r = opencons()) != <span class="hljs-number">0</span>) &#123;<br>  user_panic(<span class="hljs-string">&quot;opencons: %d&quot;</span>, r);<br> &#125;<br> <span class="hljs-comment">// stdout</span><br> <span class="hljs-keyword">if</span> ((r = dup(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>  user_panic(<span class="hljs-string">&quot;dup: %d&quot;</span>, r);<br> &#125;<br></code></pre></td></tr></table></figure><p>在shell初始化的过程中有上述代码，设置了文件描述符的0和1分别为标准输入和标准输出。</p><p>6.7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;;) &#123;<br>  <span class="hljs-keyword">if</span> (interactive) &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n$ &quot;</span>);<br>  &#125;<br>  readline(buf, <span class="hljs-keyword">sizeof</span> buf);<br><br>  <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>   <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (echocmds) &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;# %s\n&quot;</span>, buf);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((r = fork()) &lt; <span class="hljs-number">0</span>) &#123;<br>   user_panic(<span class="hljs-string">&quot;fork: %d&quot;</span>, r);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>   runcmd(buf);<br>   <span class="hljs-built_in">exit</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   wait(r);<br>  &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>参照上述代码，在MOS中我们用到的shell命令除了<code>echocmds</code>和注释两种情况外，都需要<code>fork</code>一个子shell来处理输入的命令。</p><p>Linux的<code>cd</code>指令使用频率较高，若设置为外部指令必然会在<code>cd</code>的时候多次调用<code>fork</code>生成子进程，这显然是低效的。将其设置为内部指令可以切实提高我们操作系统的效率。</p><p>6.8</p><p><img src="/img/lab6-1.PNG" alt="alt text"></p><ul><li>总共spawn了两次，分别是由最初被<code>fork</code>出的2803进程<code>spawn</code>出了3805进程，以及3004(被2803进程在<code>parsecmd</code>时<code>fork</code>得到)进程<code>spawn</code>出了4006进程。</li><li>观察到了四次进程销毁：<br>2803进程：由主shell进程fork出来的子shell进程，用于解析并执行当前命令；<br>3004进程：由2803进程fork出来的子进程，用于解析并执行管道右端的命令；<br>3805进程：由2803进程spawn出来的子进程，用于执行管道左边的命令；<br>4006进程：由3004进程spawn出来的子进程，用于执行管道右边的命令；</li></ul><h1 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h1><ol><li><code>spawn</code>函数</li></ol><p>有点类似于fork函数的思路。</p><h4 id="Step-1-打开文件"><a href="#Step-1-打开文件" class="headerlink" title="Step 1: 打开文件"></a>Step 1: 打开文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd;<br><span class="hljs-keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>打开要执行的程序文件。</li><li>如果打开失败，返回错误代码。</li></ul><h4 id="Step-2-读取-ELF-头"><a href="#Step-2-读取-ELF-头" class="headerlink" title="Step 2: 读取 ELF 头"></a>Step 2: 读取 ELF 头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> r;<br>u_char elfbuf[<span class="hljs-number">512</span>];<br><span class="hljs-keyword">if</span> ((r=readn(fd, elfbuf, <span class="hljs-keyword">sizeof</span>(Elf32_Ehdr)))&lt;<span class="hljs-number">0</span> || r!= <span class="hljs-keyword">sizeof</span>(Elf32_Ehdr)) &#123;<br>    <span class="hljs-keyword">goto</span> err;<br>&#125;<br><span class="hljs-type">const</span> Elf32_Ehdr *ehdr = elf_from(elfbuf, <span class="hljs-keyword">sizeof</span>(Elf32_Ehdr));<br><span class="hljs-keyword">if</span> (!ehdr) &#123;<br>    r = -E_NOT_EXEC;<br>    <span class="hljs-keyword">goto</span> err;<br>&#125;<br>u_long entrypoint = ehdr-&gt;e_entry;<br></code></pre></td></tr></table></figure><ul><li>从文件中读取 ELF 头部信息。</li><li>验证读取的数据是否正确且大小合适。</li><li>如果失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="Step-3-创建子进程"><a href="#Step-3-创建子进程" class="headerlink" title="Step 3: 创建子进程"></a>Step 3: 创建子进程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int child;<br>child = syscall_exofork();<br><span class="hljs-keyword">if</span> (child &lt; <span class="hljs-number">0</span>) &#123;<br>    r = child;<br>    <span class="hljs-keyword">goto</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>syscall_exofork</code> 系统调用创建一个子进程。</li><li>如果创建失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="Step-4-初始化子进程的栈"><a href="#Step-4-初始化子进程的栈" class="headerlink" title="Step 4: 初始化子进程的栈"></a>Step 4: 初始化子进程的栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int sp;<br><span class="hljs-keyword">if</span> ((r = init_stack(child, argv, &amp;sp)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> err1;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>init_stack</code> 初始化子进程的栈。</li><li>如果初始化失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="Step-5-加载-ELF-段到子进程的内存中"><a href="#Step-5-加载-ELF-段到子进程的内存中" class="headerlink" title="Step 5: 加载 ELF 段到子进程的内存中"></a>Step 5: 加载 ELF 段到子进程的内存中</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> ph_off;<br>ELF_FOREACH_PHDR_OFF (ph_off, ehdr) &#123;<br>    <span class="hljs-keyword">if</span> ((r = seek(fd, ph_off)) &lt; <span class="hljs-number">0</span> || (r = readn(fd, elfbuf, ehdr-&gt;e_phentsize)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">goto</span> err1;<br>    &#125;<br>    Elf32_Phdr *ph = (Elf32_Phdr *)elfbuf;<br>    <span class="hljs-keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;<br>        <span class="hljs-type">void</span> *bin;<br>        <span class="hljs-keyword">if</span> ((r = read_map(fd, ph-&gt;p_offset, &amp;bin)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = elf_load_seg(ph, bin, spawn_mapper, &amp;child)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err1;<br>        &#125;<br>    &#125;<br>&#125;<br>close(fd);<br></code></pre></td></tr></table></figure><ul><li>遍历 ELF 文件的程序头表，查找需要加载的段。</li><li>使用 <code>read_map</code> 读取段内容到内存。</li><li>使用 <code>elf_load_seg</code> 将段内容加载到子进程的内存中。</li><li>如果失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="设置子进程的-Trapframe-和执行入口"><a href="#设置子进程的-Trapframe-和执行入口" class="headerlink" title="设置子进程的 Trapframe 和执行入口"></a>设置子进程的 Trapframe 和执行入口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">tf</span> =</span> envs[ENVX(child)].env_tf;<br>tf.cp0_epc = entrypoint;<br>tf.regs[<span class="hljs-number">29</span>] = sp;<br><span class="hljs-keyword">if</span> ((r = syscall_set_trapframe(child, &amp;tf)) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>设置子进程的 <code>Trapframe</code>，包括程序计数器和栈指针。</li><li>如果设置失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="共享页表条目"><a href="#共享页表条目" class="headerlink" title="共享页表条目"></a>共享页表条目</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (u_int pdeno = <span class="hljs-number">0</span>; pdeno &lt;= PDX(USTACKTOP); pdeno++) &#123;<br>    <span class="hljs-keyword">if</span> (!(vpd[pdeno] &amp; PTE_V)) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (u_int pteno = <span class="hljs-number">0</span>; pteno &lt;= PTX(~<span class="hljs-number">0</span>); pteno++) &#123;<br>        u_int pn = (pdeno &lt;&lt; <span class="hljs-number">10</span>) + pteno;<br>        u_int perm = vpt[pn] &amp; ((<span class="hljs-number">1</span> &lt;&lt; PGSHIFT) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> ((perm &amp; PTE_V) &amp;&amp; (perm &amp; PTE_LIBRARY)) &#123;<br>            <span class="hljs-type">void</span> *va = (<span class="hljs-type">void</span> *)(pn &lt;&lt; PGSHIFT);<br>            <span class="hljs-keyword">if</span> ((r = syscall_mem_map(<span class="hljs-number">0</span>, va, child, va, perm)) &lt; <span class="hljs-number">0</span>) &#123;<br>                debugf(<span class="hljs-string">&quot;spawn: syscall_mem_map %x %x: %d\n&quot;</span>, va, child, r);<br>                <span class="hljs-keyword">goto</span> err2;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共享页表条目中标记为 <code>PTE_LIBRARY</code> 的页。</li><li>将这些页映射到子进程中。</li></ul><h4 id="设置子进程状态为可运行"><a href="#设置子进程状态为可运行" class="headerlink" title="设置子进程状态为可运行"></a>设置子进程状态为可运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((r = syscall_set_env_status(child, ENV_RUNNABLE)) &lt; <span class="hljs-number">0</span>) &#123;<br>    debugf(<span class="hljs-string">&quot;spawn: syscall_set_env_status %x: %d\n&quot;</span>, child, r);<br>    <span class="hljs-keyword">goto</span> err2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将子进程的状态设置为可运行。</li><li>如果失败，设置错误代码并跳转到错误处理部分。</li></ul><h4 id="错误处理部分"><a href="#错误处理部分" class="headerlink" title="错误处理部分"></a>错误处理部分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">err2:<br>    syscall_env_destroy(child);<br>    <span class="hljs-keyword">return</span> r;<br>err1:<br>    syscall_env_destroy(child);<br>err:<br>    close(fd);<br>    <span class="hljs-keyword">return</span> r;<br></code></pre></td></tr></table></figure><ul><li>如果任何步骤失败，销毁子进程并关闭文件描述符。</li><li>返回错误代码。</li></ul><p>这个函数通过一系列系统调用和 ELF 解析过程创建并初始化一个新的子进程。主要步骤包括打开可执行文件、读取 ELF 头部信息、创建子进程、初始化栈、加载 ELF 段、设置 Trapframe 和共享页表条目，最后将子进程状态设置为可运行。整个过程包括详细的错误处理，以确保在任何步骤失败时都能正确清理资源并返回适当的错误代码。</p><ol start="2"><li><code>parsecmd</code>函数</li></ol><h3 id="解析函数逻辑"><a href="#解析函数逻辑" class="headerlink" title="解析函数逻辑"></a>解析函数逻辑</h3><ol><li><p><strong>主循环</strong>：</p><ul><li>使用 <code>gettoken()</code> 函数获取下一个 token 的类型。</li><li>根据 token 的类型执行相应的操作。</li></ul></li><li><p><strong>gettoken() 函数</strong>：</p><ul><li>该函数返回当前 token 的类型，可以是 <code>0</code>（结束）、<code>&#39;w&#39;</code>（单词）、<code>&#39;&lt;&#39;</code>（输入重定向）、<code>&#39;&gt;&#39;</code>（输出重定向）、<code>&#39;|&#39;</code>（管道符号）。</li></ul></li><li><p><strong>处理逻辑</strong>：</p><ul><li><code>case 0</code>：结束条件，返回参数个数 <code>argc</code>。</li><li><code>case &#39;w&#39;</code>：将单词 <code>t</code> 存储到 <code>argv</code> 数组中，并增加 <code>argc</code>。</li><li><code>case &#39;&lt;&#39;</code>：处理输入重定向，打开文件 <code>t</code> 并复制到标准输入（0），处理错误情况。</li><li><code>case &#39;&gt;&#39;</code>：处理输出重定向，打开文件 <code>t</code> 并复制到标准输出（1），处理错误情况。</li><li><code>case &#39;|&#39;</code>：处理管道，创建管道 <code>p</code>，fork 子进程，子进程处理管道右侧，父进程处理管道左侧。</li></ul></li><li><p><strong>管道处理</strong>：</p><ul><li>创建管道 <code>p[2]</code>。</li><li>调用 <code>pipe(p)</code> 创建管道。</li><li><code>fork()</code> 函数创建子进程。</li><li>子进程中，关闭不需要的管道端，并递归调用 <code>parsecmd()</code> 处理管道右侧。</li><li>父进程中，关闭不需要的管道端，并返回当前命令的参数个数 <code>argc</code>。</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>使用 <code>debugf()</code> 输出错误消息。</li><li>使用 <code>exit()</code> 终止进程。</li></ul></li></ol><h1 id="体会感想"><a href="#体会感想" class="headerlink" title="体会感想"></a>体会感想</h1><p>比较轻松的一次lab，但是综合性也比较强，特别是后面两个函数比较复杂，涉及了之前的一些内容。</p><p>总之os告一段落了，自己对os有了整体的认识，但是具体到某个流程的分析，或许会有磕磕绊绊。收获很大。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-lab5</title>
    <link href="/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/"/>
    <url>/2024/09/06/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>5.1</p><h3 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h3><ul><li><p>当通过 kseg0 对设备进行写操作时，如果写入操作被缓存，那么实际的数据并没有直接写入设备寄存器，而是暂存在缓存中，如果发生断电等情况，缓存中的数据可能会丢失，这可能会导致数据写入失败。</p></li><li><p>设备物理内存处的数据不只由 CPU 决定，还和对应的外设的行为有关。而缓存只能记录CPU 的读写结果，无法在外设对数据进行改时及时调整。</p></li></ul><h3 id="设备操作的差异"><a href="#设备操作的差异" class="headerlink" title="设备操作的差异"></a>设备操作的差异</h3><p>对于串口设备来说，读写频繁，信号多，在相同的时间内发生错误的概论远高于IDE磁盘。<br>对于磁盘而言，磁盘一次读写的数据量较大。</p><p>5.2</p><p>根据定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_STRUCT_SIZE 256</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE PAGE_SIZE</span><br><br></code></pre></td></tr></table></figure><ul><li><p>这代表1个文件控制块大小为256B,而一个磁盘块大小为4096B,一个磁盘块最多可以存的文件控制块：$4096&#x2F;256&#x3D;16$</p></li><li><p>一个目录包含1024个指向磁盘块的指针，即最多有1024 * 16 &#x3D; 16384个文件。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BLOCK_SIZE / 4)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE (NINDIRECT * BLOCK_SIZE)</span><br></code></pre></td></tr></table></figure><ul><li>一个文件控制块有直接指针 + 间接指针共1024个 ，每个指针指向一个磁盘块，存储着该文件的一部分文件数据。文件系统支持的单个文件最大，则表示1024个指针全部有效，一共指向了1024个磁盘块存着文件数据，又一个磁盘块4KB,则单个文件最大为4KB*1024&#x3D;4MB</li></ul><p>5.3</p><p><img src="/img/lab5-1.PNG" alt="alt text"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Maximum disk size we can handle (1GB) */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISKMAX 0x40000000</span><br></code></pre></td></tr></table></figure><p>我们实验使用的内核支持的最大磁盘大小为1GB</p><p>5.4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/*serv.h*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_DIRTY 0x0004 <span class="hljs-comment">// 文件系统块缓存是脏的</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECT_SIZE 512  <span class="hljs-comment">/* 每个磁盘扇区的字节数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECT2BLK (BLOCK_SIZE / SECT_SIZE) <span class="hljs-comment">/* 扇区转换成块的比率 */</span></span><br><br><span class="hljs-comment">/* 磁盘块n，在内存中，映射到文件系统服务器的地址空间在DISKMAP+(n*BLOCK_SIZE)。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISKMAP 0x10000000</span><br><br><span class="hljs-comment">/* 我们能处理的最大磁盘大小（1GB） */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISKMAX 0x40000000</span><br><br><span class="hljs-comment">/*fs.h*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK (BLOCK_SIZE / sizeof(struct File)) <span class="hljs-comment">// 文件到块的转换率（一个文件描述符占据的块数）</span></span><br><br><span class="hljs-comment">// 文件描述符中直接块指针的数量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BLOCK_SIZE / 4) <span class="hljs-comment">// 间接块的数量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE (NINDIRECT * BLOCK_SIZE) <span class="hljs-comment">// 文件的最大大小</span></span><br></code></pre></td></tr></table></figure><p>5.5</p><p>fork 前后的父子进程共享文件描述符和定位指针。</p><p>验证程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;lib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR); <span class="hljs-comment">// 打开（如果需要则创建）一个测试文件</span><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        user_panic(<span class="hljs-string">&quot;Failed to open file&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *text = <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>    write(fd, text, <span class="hljs-built_in">strlen</span>(text));  <span class="hljs-comment">// 向文件写入数据</span><br><br>    <span class="hljs-type">int</span> pid = fork();  <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        user_panic(<span class="hljs-string">&quot;fork failed&quot;</span>);<br>        close(fd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>  buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-keyword">if</span> (read(fd, buf, <span class="hljs-number">256</span>)&lt;<span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;child read : %d&quot;</span>, fd);<br>        &#125;<br>        writef(<span class="hljs-string">&quot;child read is good &amp;&amp; child_fd == %d\n&quot;</span>,fd);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fdd</span>;</span><br>        fd_lookup(fd,&amp;fdd);<br>        writef(<span class="hljs-string">&quot;child_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">if</span>(read(fdnum, buf, <span class="hljs-number">511</span>)&lt;<span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;father read: %d&quot;</span>, fd);<br>        &#125;<br>        writef(<span class="hljs-string">&quot;father read is good &amp;&amp; father_fd == %d\n&quot;</span>,r);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fdd</span>;</span><br>        fd_lookup(fd,&amp;fdd);<br>        writef(<span class="hljs-string">&quot;father_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br>    <span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// 文件名，长度由MAXNAMELEN定义</span><br>    <span class="hljs-type">uint32_t</span> f_size;         <span class="hljs-comment">// 文件的大小，以字节为单位</span><br>    <span class="hljs-type">uint32_t</span> f_type;         <span class="hljs-comment">// 文件类型，例如常规文件、目录等</span><br>    <span class="hljs-type">uint32_t</span> f_direct[NDIRECT]; <span class="hljs-comment">// 直接指针数组，用于直接指向文件数据块</span><br>    <span class="hljs-type">uint32_t</span> f_indirect;     <span class="hljs-comment">// 间接指针，指向一个间接数据块，该块包含更多数据块的指针</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span>      <span class="hljs-comment">// 指向此文件所在目录的文件结构体指针，仅在内存中有效</span><br>    <span class="hljs-type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];<br>                             <span class="hljs-comment">// 填充字段，用于确保结构体的总大小和对齐</span><br>&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed)); <span class="hljs-comment">// 确保结构体按4字节对齐且打包，无额外空间</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span><br>    u_int fd_dev_id;       <span class="hljs-comment">// 设备ID，用于标识文件所在的设备</span><br>    u_int fd_offset;       <span class="hljs-comment">// 文件在设备上的偏移量，用于数据读写位置标识</span><br>    u_int fd_omode;        <span class="hljs-comment">// 文件或设备的操作模式，例如只读、只写或读写</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span>        <span class="hljs-comment">// 包含设备信息和操作模式的文件描述符结构</span><br>    u_int f_fileid;        <span class="hljs-comment">// 文件ID，用于唯一标识文件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span>    <span class="hljs-comment">// 文件的元数据结构体，包含文件名、大小、类型等信息</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>5.7</p><p><img src="/img/lab5-2.PNG" alt="alt text"></p><ul><li><code>ENV_CREATE(user_env)</code> 和 <code>ENV_CREATE(fs_serv)</code> 由初始化进程 <code>init()</code> 执行以创建用户和文件系统服务环境。<code>init()</code> 启动时创建这些环境，其中 <code>fs</code> 和 <code>user</code> 环境执行它们的初始化工作。</li><li><code>fs</code> 环境初始化后，<code>serv_init()</code> 和 <code>fs_init()</code> 函数运行，进入 <code>serv()</code> 循环，监听 <code>ipc_receive()</code> 的请求并将环境标记为 <code>ENV_NOT_RUNNABLE</code>，直到接收到 <code>user</code> 环境的 <code>ipc_send(fsreq)</code> 请求再变为可运行。</li><li><code>user</code> 环境向 <code>fs</code> 环境发送 <code>ipc_send(fsreq)</code> 请求来请求文件访问服务，请求后自身进入 <code>ENV_NOT_RUNNABLE</code> 状态等待响应。响应文件访问请求后，<code>ipc_send(dst_va)</code> 将请求结果发送回 <code>user</code> 环境，此时 <code>fs</code> 环境再次进入 <code>ENV_NOT_RUNNABLE</code> 状态等待下次请求处理。</li></ul><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><p>部分代码文件的主要功能（协调理解文件系统的核心框架）：</p><ul><li><code>tools</code> 目录中的文件是构建时的辅助工具的代码： <code>fsformat</code> 工具 —— 创建磁盘镜像</li><li><code>fs</code> 目录中存放的是文件系统处理相关的代码：通过 IPC 通信与用户进程 <code>user/lib/fsipc.c</code> 内的通信函数进行交互<ul><li><code>fs.c</code>：实现文件系统的基本功能函数</li><li><code>ide.c</code>：通过系统调用与磁盘镜像交互</li><li><code>serv.c</code>：进程的主干函数</li></ul></li><li><code>user/lib</code> 目录下存放了用户程序的库函数：<ul><li>系统用户程序库的一部分，抽象操作系统文件系统的文件，以及这些文件和信号源控制的文件。</li><li><code>fsipc.c</code>：实现与文件系统服务进程的交互</li><li><code>file.c</code>：实现文件系统的用户接口</li><li><code>fd.c</code>：实现文件描述符</li></ul></li></ul><p><strong>IDE磁盘驱动（外设控制）</strong>：</p><ul><li><p>在 MIPS 体系结构下，我们使用 MMIO（内存映射 IO）机制访问设备寄存器。MMIO 使用不同的物理内存地址为设备寄存器编址，将一部分对物理内存的访问 “重定向” 到设备地址空间中。CPU 对这部分物理内存的访问等同于对相应设备的访问。</p></li><li><p>外设是通过读写寄存器来进行数据通信，设备寄存器通常包括控制寄存器、状态寄存器和数据寄存器，这些寄存器被映射到指定的物理地址空间。</p></li></ul><p><strong>文件系统</strong>：</p><ul><li>磁盘布局：<br>MOS 以磁盘最开始的一个磁盘块当作引导扇区和分区表使用。接下来的一个磁盘块作为超级块（Super Block），用来描述文件系统的基本信息。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Super</span> &#123;</span><br> <span class="hljs-type">uint32_t</span> s_magic;   <span class="hljs-comment">// Magic number: FS_MAGIC</span><br> <span class="hljs-type">uint32_t</span> s_nblocks; <span class="hljs-comment">// Total number of blocks on disk</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">s_root</span>;</span> <span class="hljs-comment">// Root directory node</span><br> &#125;;<br></code></pre></td></tr></table></figure><ul><li>文件系统结构：</li></ul><p>磁盘抽象成由磁盘块组成，每个磁盘块由8个连续的扇区组成，扇区是物理上的结构，而磁盘块是逻辑上存在的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> &#123;</span> <span class="hljs-comment">//tools/fsformat.c</span><br><span class="hljs-type">uint8_t</span> data[BY2BLK];<br><span class="hljs-type">uint32_t</span> type;<br>&#125; disk[NBLOCK];<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br><span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span><br><span class="hljs-type">uint32_t</span> f_size; <span class="hljs-comment">// file size in bytes</span><br><span class="hljs-type">uint32_t</span> f_type; <span class="hljs-comment">// file type</span><br><span class="hljs-type">uint32_t</span> f_direct[NDIRECT];<br><span class="hljs-type">uint32_t</span> f_indirect;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory.</span><br><span class="hljs-type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];<br>&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed));<br></code></pre></td></tr></table></figure><p>上述定义了文件控制块，是整个文件系统需要理解的最关键的结构体，其中指明了文件的索引方式，文件控制块的大小，文件控制块的名称</p><p><strong>文件系统的用户接口</strong>：</p><p><img src="/img/lab5-3.PNG" alt="alt text"><br>用户程序在发出文件系统操作请求时，将请求的内容放在对应的结构体中进行消息的传递，fs_serv 进程收到其他进行的 IPC 请求后，IPC 传递的消息包含了请求的类型和其他必要的参数，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果重新通过IPC反馈给用户程序。用户程序在发出文件系统操作请求时，将请求的内容放在对应的结构体中进行消息的传递，fs_serv 进程收到其他进行的 IPC 请求后，IPC 传递的消息包含了请求的类型和其他必要的参数，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果重新通过IPC馈给用户程序。</p><h1 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h1><p>lab5课下总体实验难度较大，涉及较多的结构体。同时综合了lab4的进程ipc问题。<br>我们首先需要弄明白每个结构体的作用，弄清楚文件系统抽象出来的结构体对应到哪一部分，结构体中的每个属性的作用。<br>其次，我们需要再次结合lab4的内容，搞清楚文件系统服务的函数调用过程，文件系统服务是一个单独的文件服务进程进行管理的，其他进程需要通过ipc与之通信，才能在进程中对文件进行操作。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os,文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统基础</title>
    <link href="/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个分布式系统是:<strong>一组独立的计算机</strong>，在用户看来是一个<strong>单一的连贯系统</strong>。其中，位于联网计算机上的硬件或软件组件仅通过传递消息来通信和协调其操作。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>资源共享</strong>：分布式系统中的多个节点可以共享资源（如计算能力、存储和网络带宽），并且这些资源可以被多个用户和应用程序访问。</p></li><li><p><strong>并发性</strong>：分布式系统允许多个用户和应用程序同时访问和操作系统中的资源。<strong>这种并发性是分布式系统设计的核心</strong>。</p></li><li><p><strong>透明性</strong>：用户和应用程序通常不需要关心资源的物理位置。分布式系统通过中间件和协议提供透明性，使得资源的访问和管理看起来像是在单一系统中进行。</p></li><li><p><strong>容错性</strong>：分布式系统能够在部分节点发生故障时继续运行。系统通常会实现冗余和备份机制，以确保高可用性。</p></li><li><p><strong>可扩展性</strong>：系统规模有一定规模的扩展，无论是资源还是用户，系统的性能保持在一定的水平。</p></li><li><p><strong>异构性</strong>：分布式系统可以由不同类型的计算机和操作系统组成，能够在异构环境中协同工作。</p></li><li><p><strong>没有全局时钟</strong>：每个机器的有各自的时间，没有办法做到统一，程序间的协调靠交换消息</p></li><li><p><strong>故障独立性</strong>：一些进程出现故障，并不能保证其它进程都能知道</p></li></ol><h3 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h3><ol><li><p><strong>通信管理</strong>：分布式中间件提供了不同系统或服务之间的通信机制，支持异步消息传递、远程过程调用（RPC）等，简化了系统间的交互。</p></li><li><p><strong>负载均衡</strong>：通过分布式中间件，可以实现请求的负载均衡，将流量分配到多个服务实例上，提高系统的可用性和性能。</p></li><li><p><strong>事务管理</strong>：中间件可以提供分布式事务管理，确保多个服务之间的数据一致性。</p></li><li><p><strong>安全性</strong>：中间件可以提供安全机制，如身份验证和授权，确保只有经过授权的用户和服务可以访问特定资源。</p></li><li><p><strong>监控与管理</strong>：分布式中间件通常集成监控工具，帮助开发者和运维人员实时监控系统的健康状态和性能指标。</p></li><li><p><strong>容错与恢复</strong>：中间件可以实现故障检测和自动恢复机制，提高系统的可靠性和可用性。</p></li></ol><p>中间件的插入，实现了分布式系统对用户的透明性，用户不用再关注分布式系统底层的架构和通信，只需要调用中间层暴露出来的接口。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
